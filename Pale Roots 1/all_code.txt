using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    public class Animation
    {
        public Texture2D Texture { get; private set; }
        public int FrameCount { get; private set; }
        public int SheetRow { get; private set; }
        public float FrameSpeed { get; private set; }
        public bool IsLooping { get; private set; }
        public int TotalRows { get; private set; }

        // NEW: Store the exact width of a single frame
        public int FrameWidth { get; private set; }
        public int FrameHeight { get; private set; }

        public bool IsGrid { get; set; }

        public Animation(Texture2D texture, int frameCount, int sheetRow, float frameSpeed, bool isLooping, int totalRows = 1, int customWidth = 0, bool isGrid = false)
        {
            Texture = texture;
            FrameCount = frameCount;
            SheetRow = sheetRow;
            FrameSpeed = frameSpeed;
            IsLooping = isLooping;
            TotalRows = totalRows;
            IsGrid = isGrid; // NEW: Stores if this is a directional sheet

            if (customWidth > 0)
                FrameWidth = customWidth;
            else
                FrameWidth = texture.Width / frameCount;

            // If it's a grid, the height is the full texture divided by rows
            FrameHeight = texture.Height / totalRows;
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    public class AnimationManager
    {
        private Dictionary<string, Animation> _anims = new Dictionary<string, Animation>();
        private Animation _currentAnimation;
        private string _currentKey;

        private float _timer;
        public int CurrentFrame { get; private set; }

        public float LayerDepth { get; set; }

        public void AddAnimation(string key, Animation animation)
        {
            _anims[key] = animation;
        }
        public void Play(string key)
        {
            if (_currentKey == key) return;

            if (_anims.ContainsKey(key))
            {
                _currentKey = key;
                _currentAnimation = _anims[key];
                CurrentFrame = 0;
                _timer = 0;
            }
        }
        public void Update(GameTime gameTime)
        {
            if (_currentAnimation == null) return;

            _timer += (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            if (_timer > _currentAnimation.FrameSpeed)
            {
                _timer = 0f;
                CurrentFrame++;

                if (CurrentFrame >= _currentAnimation.FrameCount)
                {
                    if (_currentAnimation.IsLooping)
                    {
                        CurrentFrame = 0;
                    }
                    else
                    {
                        CurrentFrame = _currentAnimation.FrameCount - 1;
                    }
                }
            }
        }
        public void Draw(SpriteBatch spriteBatch, Vector2 position, float scale, SpriteEffects effect, int direction = 0)
        {
            if (_currentAnimation == null) return;

            int frameWidth = _currentAnimation.FrameWidth;
            int frameHeight = _currentAnimation.FrameHeight;
            int currentRow = _currentAnimation.SheetRow;

            // POLYMORPHIC LOGIC:
            // If it's a Grid (Enemy/Ally), we ignore the 'effect' flip and change the Y row instead.
            // Assuming standard sheets: 0:Down, 1:Left, 2:Right, 3:Up (Adjust based on your asset)
            if (_currentAnimation.IsGrid)
            {
                currentRow = direction;
                effect = SpriteEffects.None; // Grid handles direction, so don't flip
            }

            Rectangle source = new Rectangle(
                CurrentFrame * frameWidth,
                currentRow * frameHeight,
                frameWidth,
                frameHeight
            );

            // Origin at Bottom Center (Feet)
            Vector2 origin = new Vector2(frameWidth / 2f, frameHeight);

            spriteBatch.Draw(
                _currentAnimation.Texture,
                position,
                source,
                Color.White,
                0f,
                origin,
                scale,
                effect,
                LayerDepth
            );
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Media;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    public class AudioManager
    {
        // Configuration
        private float _fadeSpeed = 0.5f;

        // State
        private float _currentVolume = 0f;
        private float _targetVolume = 0f;

        // Tracks
        private Song _currentSong;
        private Song _pendingSong;

        // Playlists
        public Song MenuSong { get; set; }
        public Song IntroSong { get; set; }
        public Song DeathSong { get; set; }
        public Song OutroSong { get; set; } // Used for Victory/Outro/Credits

        private List<Song> _combatSongs = new List<Song>();

        public AudioManager()
        {
            // Initialize volume to silent so we fade in
            MediaPlayer.Volume = 0f;
        }

        public void AddCombatSong(Song song)
        {
            _combatSongs.Add(song);
        }

        public void Update(GameTime gameTime)
        {
            float dt = (float)gameTime.ElapsedGameTime.TotalSeconds;

            // 1. Fading Logic
            if (_currentVolume < _targetVolume)
            {
                _currentVolume += _fadeSpeed * dt;
                if (_currentVolume > _targetVolume) _currentVolume = _targetVolume;
            }
            else if (_currentVolume > _targetVolume)
            {
                _currentVolume -= _fadeSpeed * dt;
                if (_currentVolume < _targetVolume) _currentVolume = _targetVolume;
            }

            MediaPlayer.Volume = _currentVolume;

            // 2. Cross-Fade Execution
            if (_pendingSong != null && _currentVolume <= 0.01f)
            {
                try
                {
                    MediaPlayer.Stop();
                    MediaPlayer.Play(_pendingSong);

                    // Loop non-combat songs
                    // If we are in combat, we don't loop (so we can shuffle)
                    // If we are in menu/outro, we loop.
                    // We handle this logic loosely here, or strictly in HandleMusicState

                    _currentSong = _pendingSong;
                    _pendingSong = null;
                    _targetVolume = 0.5f; // Fade back in
                }
                catch { }
            }
        }

        // The main interface for Game1 to ask for music
        public void HandleMusicState(GameState state)
        {
            // If we are currently fading out (Pending exists), wait.
            if (_pendingSong != null) return;

            switch (state)
            {
                case GameState.Menu:
                    RequestTrack(MenuSong, true);
                    break;
                case GameState.Intro:
                    RequestTrack(IntroSong, false);
                    break;
                case GameState.GameOver:
                    RequestTrack(DeathSong, false);
                    break;
                case GameState.Victory:
                case GameState.Outro:
                case GameState.Credits:
                    RequestTrack(OutroSong, true);
                    break;

                case GameState.Gameplay:
                case GameState.LevelUp:
                    HandleCombatMusic();
                    break;
            }
        }

        private void HandleCombatMusic()
        {
            // Check if we are playing a "Theme" song that shouldn't be here
            bool isWrongTheme = (_currentSong == MenuSong || _currentSong == IntroSong ||
                                 _currentSong == DeathSong || _currentSong == OutroSong);

            // Check if the current song has finished naturally
            bool isSilence = (MediaPlayer.State == MediaState.Stopped);

            if (isWrongTheme)
            {
                RequestTrack(GetRandomCombatTrack(), false);
            }
            else if (isSilence)
            {
                // Song ended naturally. Pick next, start immediately at 0 vol, fade in.
                Song next = GetRandomCombatTrack();
                PlayImmediate(next);
            }
        }

        private void RequestTrack(Song song, bool loop)
        {
            if (_currentSong == song && _pendingSong == null) return;
            if (_pendingSong == song) return;

            MediaPlayer.IsRepeating = loop;
            _pendingSong = song;
            _targetVolume = 0.0f; // Fade out current
        }

        private void PlayImmediate(Song song)
        {
            try
            {
                MediaPlayer.Play(song);
                MediaPlayer.IsRepeating = false;
                _currentSong = song;
                _currentVolume = 0f;
                _targetVolume = 0.5f;
            }
            catch { }
        }

        private Song GetRandomCombatTrack()
        {
            if (_combatSongs.Count == 0) return null;
            Song candidate;
            int attempts = 0;
            do
            {
                int index = CombatSystem.RandomInt(0, _combatSongs.Count);
                candidate = _combatSongs[index];
                attempts++;
            }
            while (candidate == _currentSong && attempts < 5);
            return candidate;
        }

        public void Stop()
        {
            MediaPlayer.Stop();
            _currentSong = null;
            _pendingSong = null;
            _currentVolume = 0.5f;
            _targetVolume = 0.5f;
        }
    }
}
using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
//using AnimatedSprite; // Needed to see the Sprite base class

namespace Pale_Roots_1
{
    public class Collectible : Sprite
    {
        public int HealthValue { get; private set; }

        // Static to share memory across all collectibles
        private static Texture2D healthBarTexture;

        public Collectible(Game game, Texture2D texture, Vector2 position, int frameCount)
            : base(game, texture, position, frameCount, 1)
        {
            Random r = new Random();
            HealthValue = r.Next(50, 101);

            // Lazy loading the texture once
            if (healthBarTexture == null)
            {
                healthBarTexture = new Texture2D(game.GraphicsDevice, 1, 1);
                healthBarTexture.SetData(new[] { Color.White });
            }
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            base.Draw(spriteBatch);

            // Draw health bar above it
            Rectangle barRect = new Rectangle(
                (int)position.X,
                (int)position.Y - 10,
                HealthValue / 2,
                5
            );

            spriteBatch.Draw(healthBarTexture, barRect, Color.Green);

            // Ensure you have a font named "NameID" in your Content pipeline, 
            // otherwise this line will crash.
            // spriteBatch.DrawString(
            //    game.Content.Load<SpriteFont>("NameID"),
            //    HealthValue.ToString(),
            //    new Vector2(position.X, position.Y - 25),
            //    Color.White
            // );
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    public class CutsceneManager
    {

        public class CutsceneSlide
        {
            public Texture2D Texture;
            public string Text;
            public float Duration;

            // Movement Variables
            public float ZoomStart;
            public float ZoomEnd;
            public Vector2 PanStart;
            public Vector2 PanEnd;

            private float _fadeAlpha = 1.0f;

            public CutsceneSlide(Texture2D texture, string text, float duration, float zStart, float zEnd, Vector2 pStart, Vector2 pEnd)
            {
                Texture = texture;
                Text = text;
                Duration = duration;
                ZoomStart = zStart;
                ZoomEnd = zEnd;
                PanStart = pStart;
                PanEnd = pEnd;
            }
        }

        private List<CutsceneSlide> _slides = new List<CutsceneSlide>();
        private int _currentIndex = 0;
        private float _timer = 0f;


        private Texture2D _pixel;
        private SpriteFont _font;

        public bool IsFinished { get; private set; } = false;

        public CutsceneManager(Game game)
        {

            _pixel = new Texture2D(game.GraphicsDevice, 1, 1);
            _pixel.SetData(new[] { Color.White });


            try
            {
                _font = game.Content.Load<SpriteFont>("cutsceneFont");
            }
            catch
            {
                
            }


            //_slides.Add(new CutsceneSlide("In the beginning, the roots were pale...", Color.Black, 3000f));
            //_slides.Add(new CutsceneSlide("The war consumed everything.", Color.DarkRed, 3000f));
            //_slides.Add(new CutsceneSlide("Now, only the Skeleton King remains.", Color.DarkSlateGray, 3000f));
            //_slides.Add(new CutsceneSlide("Press SPACE to skip...", Color.Black, 2000f));
        }
        public void AddSlide(CutsceneSlide slide)
        {
            _slides.Add(slide);
        }

        public void Update(GameTime gameTime)
        {
            if (IsFinished) return;

            float dt = (float)gameTime.ElapsedGameTime.TotalMilliseconds;
            _timer += dt;


            if (Keyboard.GetState().IsKeyDown(Keys.Space) || Keyboard.GetState().IsKeyDown(Keys.Enter))
            {
                IsFinished = true;
            }


            if (_timer >= _slides[_currentIndex].Duration)
            {
                _timer = 0;
                _currentIndex++;

                if (_currentIndex >= _slides.Count)
                {
                    IsFinished = true;
                }
            }
        }

        public void ClearSlides()
        {
            _slides.Clear();
            _currentIndex = 0;
            _timer = 0f;
            IsFinished = false;
        }

        public void Reset()
        {
            _currentIndex = 0;
            _timer = 0f;
            IsFinished = false;
        }

        public void Draw(SpriteBatch spriteBatch, int screenWidth, int screenHeight)
        {
            if (IsFinished) return;

            CutsceneSlide slide = _slides[_currentIndex];

            // 1. CALCULATE PROGRESS
            float progress = _timer / slide.Duration;

            // 2. CALCULATE CINEMATIC SCALE (FILL SCREEN)
            // Determine how much we need to scale the image to cover the whole screen
            float scaleX = (float)screenWidth / slide.Texture.Width;
            float scaleY = (float)screenHeight / slide.Texture.Height;
            float baseScale = Math.Max(scaleX, scaleY); // Use the larger scale to ensure coverage

            // 3. APPLY ZOOM & PAN
            float currentZoom = MathHelper.Lerp(slide.ZoomStart, slide.ZoomEnd, progress);
            float finalScale = baseScale * currentZoom;

            Vector2 currentPan = Vector2.Lerp(slide.PanStart, slide.PanEnd, progress);

            // 4. CALCULATE FADE
            float fadeDuration = slide.Duration * 0.15f;
            float alpha = 1.0f;

            if (_timer < fadeDuration) alpha = _timer / fadeDuration;
            else if (_timer > slide.Duration - fadeDuration)
            {
                float timeLeft = slide.Duration - _timer;
                alpha = timeLeft / fadeDuration;
            }

            // 5. DRAW IMAGE (Centered origin)
            Vector2 origin = new Vector2(slide.Texture.Width / 2, slide.Texture.Height / 2);
            Vector2 screenCenter = new Vector2(screenWidth / 2, screenHeight / 2);

            spriteBatch.Draw(slide.Texture, screenCenter + currentPan, null, Color.White * alpha,
                0f, origin, finalScale, SpriteEffects.None, 0f);

            // 6. DRAW TEXT WITH BACKGROUND
            if (_font != null)
            {
                // Main Story Text
                Vector2 textSize = _font.MeasureString(slide.Text);
                Vector2 textPos = new Vector2((screenWidth / 2) - (textSize.X / 2), screenHeight - 200);

                // Draw Semi-Transparent Box behind text
                Rectangle bgRect = new Rectangle(
                    (int)textPos.X - 20,
                    (int)textPos.Y - 10,
                    (int)textSize.X + 40,
                    (int)textSize.Y + 20
                );
                spriteBatch.Draw(_pixel, bgRect, Color.Black * 0.6f * alpha);
                spriteBatch.DrawString(_font, slide.Text, textPos, Color.White * alpha);

                // Skip Prompt (Bottom Right)
                string skipMsg = "Press SPACE to Skip";
                Vector2 skipSize = _font.MeasureString(skipMsg);
                Vector2 skipPos = new Vector2(screenWidth - skipSize.X - 40, screenHeight - 60);

                spriteBatch.DrawString(_font, skipMsg, skipPos, Color.Gray * alpha * 0.8f);
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    public class Game1 : Game
    {
        private GraphicsDeviceManager _graphics;
        private SpriteBatch _spriteBatch;

        private Texture2D _uiPixel;
        private SpriteFont _uiFont;

        // NEW: Background Texture for the menu
        private Texture2D _menuBackground;

        private ChaseAndFireEngine _gameEngine;
        private CutsceneManager _cutsceneManager;

        // Menu Buttons
        private Rectangle _playBtnRect;
        private Rectangle _quitBtnRect;

        private List<Texture2D> _outroImages = new List<Texture2D>();

        // Input Safety
        private float _uiInputDelay = 0f;
        private const float SAFETY_DELAY = 0.5f;

        // --- NEW AUDIO MANAGER ---
        private AudioManager _audioManager;

        private int _nextLevelThreshold = 3;
        private int _levelStep = 4;

        private UpgradeManager _upgradeManager;
        private List<UpgradeManager.UpgradeOption> _currentUpgradeOptions;

        // Progression Logic
        private const int WIN_CONDITION_KILLS = 1;

        // Spell Icons
        private Texture2D[] _spellIcons;
        private Keys[] _spellKeys = { Keys.D1, Keys.D2, Keys.D3, Keys.D4, Keys.D5, Keys.D6 };

        private Texture2D _dashIcon;
        private Texture2D _heavyAttackIcon;

        // NEW: Outro List
        private List<Texture2D> _outroSlides = new List<Texture2D>();

        // UI Colors (Medieval Sci-Fantasy Theme)
        Color _hudColor = new Color(10, 10, 15, 200);
        Color _healthColor = new Color(180, 20, 20);
        Color _staminaColor = new Color(50, 205, 50);

        private float _creditsScrollY = 0f;
        private string _creditsText =
            "PALE ROOTS\n\n" +
            "A Game by Ryan Barry\n\n" +
            "PROGRAMMING\nRyan Barry\n\n" +
            "ART ASSETS\nItch Artists\n\n" +
            "MUSIC\nRyan Barry\n\n" +
            "SPECIAL THANKS\nPaul Powell\nNeil Gannon\n\n\n" +
            "Thank you for playing!";

        // Button Styling
        Color _btnNormal = new Color(20, 20, 30, 220);
        Color _btnHover = new Color(40, 60, 100, 240);
        Color _borderNormal = new Color(60, 60, 80);
        Color _borderHover = Color.Cyan;

        // GameState is now in GameState.cs (Global Enum)
        private GameState _currentState = GameState.Menu;
        private bool _hasStarted = false;

        public Game1()
        {
            _graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
            IsMouseVisible = true;
            new InputEngine(this);

            // Initialize the Audio Manager
            _audioManager = new AudioManager();
        }

        protected override void Initialize()
        {
            _graphics.PreferredBackBufferWidth = 1920;
            _graphics.PreferredBackBufferHeight = 1080;
            _graphics.ApplyChanges();

            // Setup Menu Buttons (Centered)
            int centerW = _graphics.PreferredBackBufferWidth / 2;
            int centerH = _graphics.PreferredBackBufferHeight / 2;

            // Make buttons slightly wider and thinner for a sleeker look
            _playBtnRect = new Rectangle(centerW - 120, centerH - 40, 240, 50);
            _quitBtnRect = new Rectangle(centerW - 120, centerH + 40, 240, 50);

            base.Initialize();
        }

        protected override void LoadContent()
        {
            // --- AUDIO LOADING (Delegated to Manager) ---
            _audioManager.MenuSong = Content.Load<Song>("PaleRootsMenu");
            _audioManager.IntroSong = Content.Load<Song>("Whimsy");
            _audioManager.DeathSong = Content.Load<Song>("Sad");

            // Load Outro once, assign to Outro
            Song outro = Content.Load<Song>("Ihavenoidea");
            _audioManager.OutroSong = outro;

            _audioManager.AddCombatSong(Content.Load<Song>("Guitar"));
            _audioManager.AddCombatSong(Content.Load<Song>("MoreGuitar"));
            _audioManager.AddCombatSong(Content.Load<Song>("Groovy"));
            _audioManager.AddCombatSong(Content.Load<Song>("ihavenoidea"));
            _audioManager.AddCombatSong(Content.Load<Song>("uhm"));
            // --------------------------------------------

            _spellIcons = new Texture2D[6];
            _spellIcons[0] = Content.Load<Texture2D>("Effects/SmiteIcon");
            _spellIcons[1] = Content.Load<Texture2D>("Effects/HolyNovaIcon");
            _spellIcons[2] = Content.Load<Texture2D>("Effects/HeavensFuryIcon");
            _spellIcons[3] = Content.Load<Texture2D>("Effects/HolyShieldIcon");
            _spellIcons[4] = Content.Load<Texture2D>("Effects/ElectricityIcon");
            _spellIcons[5] = Content.Load<Texture2D>("Effects/SwordJusticeIcon");

            _dashIcon = Content.Load<Texture2D>("Effects/DashIcon");
            _heavyAttackIcon = Content.Load<Texture2D>("Effects/HeavyIcon");

            _spriteBatch = new SpriteBatch(GraphicsDevice);
            _gameEngine = new ChaseAndFireEngine(this);

            _upgradeManager = new UpgradeManager(
               _gameEngine.GetPlayer(),
               _gameEngine.GetSpellManager(),
               _spellIcons,
               _dashIcon,
               _heavyAttackIcon,
               GraphicsDevice
           );

            _cutsceneManager = new CutsceneManager(this);
            Texture2D[] slides = new Texture2D[9];
            for (int i = 1; i < 9; i++)
            {
                slides[i] = Content.Load<Texture2D>("cutscene_image_" + i);
            }

            for (int i = 1; i < 8; i++)
            {
                _outroSlides.Add(Content.Load<Texture2D>("outro_image_" + i));
            }

            _uiPixel = new Texture2D(GraphicsDevice, 1, 1);
            _uiPixel.SetData(new[] { Color.White });

            try { _uiFont = Content.Load<SpriteFont>("cutsceneFont"); }
            catch { }

            try { _menuBackground = Content.Load<Texture2D>("menu_background"); }
            catch { }

            // Cutscene Setup
            float dur = 5500f;
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[1], "Decades ago Scholars discovered that the universe was not forged from nothing,\n it was brought to fruition by beings greater than our comprehension", dur + 2000, 1.0f, 1.05f, Vector2.Zero, Vector2.Zero));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[2], "One of these beings known as Atun created humanity, in hopes in return he would get their devoted undying love.", dur, 1.05f, 1.05f, new Vector2(-30, 0), new Vector2(30, 0)));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[3], "But soon after humanity discovered it was he who made civilisation the cruel unforgiving reality it was,\n a rancorous feeling was left souring their tounge.", dur, 1.1f, 1.0f, Vector2.Zero, Vector2.Zero));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[4], "Insulted, Atun withdrew any power he was yeilding to the world he once held so precious.", dur, 1.05f, 1.05f, new Vector2(0, 30), new Vector2(0, -30)));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[5], "The Roots of his power went Pale, and the love his people had for him turned to blaising rage as\n they were forsaken further.", dur, 1.0f, 1.08f, Vector2.Zero, Vector2.Zero));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[6], "In news of a weakened civilisation, Predatory colonys smelled blood in the waters of the Galaxy.", dur, 1.05f, 1.05f, new Vector2(30, 0), new Vector2(-30, 0)));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[7], "Led by Nivellin, a war Hero with inexplicable power. He had came to take back ther land that was once his to Rule.", dur, 1.0f, 1.15f, Vector2.Zero, Vector2.Zero));
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(slides[8], "War was set in Motion, as was the Justice for Humanity", dur, 1.1f, 1.0f, Vector2.Zero, Vector2.Zero));
        }

        protected override void Update(GameTime gameTime)
        {
            // --- UPDATE AUDIO MANAGER ---
            _audioManager.HandleMusicState(_currentState);
            _audioManager.Update(gameTime);
            // ----------------------------

            switch (_currentState)
            {
                case GameState.Intro:
                    _cutsceneManager.Update(gameTime);
                    if (Keyboard.GetState().IsKeyDown(Keys.Space) || _cutsceneManager.IsFinished)
                    {
                        _currentState = GameState.Gameplay;
                        _hasStarted = true;
                    }
                    break;


                case GameState.Outro:
                    _cutsceneManager.Update(gameTime);

                    if (Keyboard.GetState().IsKeyDown(Keys.Space) || _cutsceneManager.IsFinished)
                    {
                        _currentState = GameState.Credits;
                        _creditsScrollY = GraphicsDevice.Viewport.Height;
                    }
                    break;

                case GameState.Menu:
                    IsMouseVisible = true;
                    MouseState ms = Mouse.GetState();
                    Point mousePoint = new Point(ms.X, ms.Y);

                    if (ms.LeftButton == ButtonState.Pressed)
                    {
                        if (_playBtnRect.Contains(mousePoint))
                        {
                            if (!_hasStarted) _currentState = GameState.Intro;
                            else _currentState = GameState.Gameplay;
                        }
                        else if (_quitBtnRect.Contains(mousePoint)) Exit();
                    }
                    break;

                case GameState.Credits:
                    // Scroll text upwards
                    _creditsScrollY -= 60f * (float)gameTime.ElapsedGameTime.TotalSeconds;

                    // Check for Spacebar OR if text has scrolled off screen
                    if (Keyboard.GetState().IsKeyDown(Keys.Space) || _creditsScrollY < -1500f)
                    {
                        // 1. Change State to Menu
                        _currentState = GameState.Menu;
                        _hasStarted = false;

                        // 2. Perform Soft Reset (Reset gameplay, keep audio/assets alive)
                        SoftResetGame();
                    }
                    break;

                case GameState.Gameplay:
                    if (InputEngine.IsKeyPressed(Keys.Escape)) _currentState = GameState.Menu;

                    if (_gameEngine != null)
                    {
                        _gameEngine.Update(gameTime);

                        // Win
                        if (_gameEngine.EnemiesKilled >= WIN_CONDITION_KILLS) _currentState = GameState.Victory;

                        // Loss
                        if (!_gameEngine.GetPlayer().IsAlive) _currentState = GameState.GameOver;

                        // Level Up
                        if (_gameEngine.EnemiesKilled >= _nextLevelThreshold)
                        {
                            _currentUpgradeOptions = _upgradeManager.GetRandomOptions(3);
                            if (_currentUpgradeOptions.Count > 0)
                            {
                                _currentState = GameState.LevelUp;
                                _uiInputDelay = SAFETY_DELAY; // START THE DELAY TIMER
                            }
                            _levelStep += 4; // Smaller step (easier)
                            _nextLevelThreshold += _levelStep;
                        }
                    }
                    break;

                case GameState.LevelUp:
                    IsMouseVisible = true;
                    // Decrement Timer
                    if (_uiInputDelay > 0) _uiInputDelay -= (float)gameTime.ElapsedGameTime.TotalSeconds;
                    else HandleLevelUpInput();
                    break;

                case GameState.Victory:
                case GameState.GameOver:
                    IsMouseVisible = true;
                    HandleEndGameInput();
                    break;
            }
            base.Update(gameTime);
        }

        private void SoftResetGame()
        {
            // Reset Game Engine (Player, Level, Enemies)
            _gameEngine = new ChaseAndFireEngine(this);

            // Re-link the UpgradeManager to the NEW Player/SpellManager
            _upgradeManager = new UpgradeManager(
                _gameEngine.GetPlayer(),
                _gameEngine.GetSpellManager(),
                _spellIcons,
                _dashIcon,
                _heavyAttackIcon,
                GraphicsDevice
            );

            // Reset Progression Variables
            _nextLevelThreshold = 3;
            _levelStep = 4;

            // Reset Input State so we don't accidentally click something immediately
            InputEngine.ClearState();
        }
        private void HandleLevelUpInput()
        {
            if (InputEngine.IsMouseLeftClick())
            {
                MouseState ms = Mouse.GetState();

                Rectangle screen = GraphicsDevice.Viewport.Bounds;
                int cardWidth = 200;
                int cardHeight = 300;
                int spacing = 50;
                int totalWidth = (_currentUpgradeOptions.Count * cardWidth) + ((_currentUpgradeOptions.Count - 1) * spacing);
                int startX = (screen.Width / 2) - (totalWidth / 2);
                int startY = (screen.Height / 2) - (cardHeight / 2);

                for (int i = 0; i < _currentUpgradeOptions.Count; i++)
                {
                    Rectangle cardRect = new Rectangle(startX + (i * (cardWidth + spacing)), startY, cardWidth, cardHeight);

                    if (cardRect.Contains(ms.Position))
                    {
                        _currentUpgradeOptions[i].ApplyAction.Invoke();
                        _currentState = GameState.Gameplay;
                        InputEngine.ClearState();
                        break;
                    }
                }
            }
        }

        private void HandleEndGameInput()
        {
            MouseState ms = Mouse.GetState();
            int centerW = GraphicsDevice.Viewport.Width / 2;
            int centerH = GraphicsDevice.Viewport.Height / 2;

            Rectangle playAgainRect = new Rectangle(centerW - 100, centerH, 200, 50);
            Rectangle quitRect = new Rectangle(centerW - 100, centerH + 70, 200, 50);

            if (InputEngine.IsMouseLeftClick())
            {
                if (playAgainRect.Contains(ms.Position))
                {
                    if (_currentState == GameState.Victory)
                    {
                        StartOutroSequence();
                    }
                    else
                    {
                        SoftResetGame();
                        _currentState = GameState.Gameplay;
                        _hasStarted = true;

                        // Stop audio on death/restart so it resets
                        _audioManager.Stop();
                    }
                    InputEngine.ClearState();
                }
                else if (quitRect.Contains(ms.Position))
                {
                    Exit();
                }
            }
        }

        private void StartOutroSequence()
        {
            _cutsceneManager.ClearSlides();
            float dur = 6000f;

            // Slide 1: Zoom In
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[0],
                "The Skeleton King crumbles, his reign of bone and ash finally at an end.",
                dur, 1.0f, 1.15f, Vector2.Zero, Vector2.Zero));

            // Slide 2: Pan Right
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[1],
                "Without his dark magic, the Pale Roots begin to wither and retreat.",
                dur, 1.1f, 1.1f, new Vector2(-50, 0), new Vector2(50, 0)));

            // Slide 3: Zoom Out
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[2],
                "Where death once choked the land, the first sprouts of green life return.",
                dur, 1.2f, 1.0f, Vector2.Zero, Vector2.Zero));

            // Slide 4: Pan Up
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[3],
                "The survivors emerge from the ruins, looking up at a clear sky for the first time in years.",
                dur, 1.1f, 1.1f, new Vector2(0, 50), new Vector2(0, -50)));

            // Slide 5: Zoom In
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[4],
                "We will rebuild. Not as subjects of a tyrant, but as free people.",
                dur, 1.0f, 1.1f, Vector2.Zero, Vector2.Zero));

            // Slide 6: Static -> Zoom
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[5],
                "The scars of this war will remain, a reminder of what was lost.",
                dur, 1.05f, 1.15f, Vector2.Zero, Vector2.Zero));

            // Slide 7: Slow Pan
            _cutsceneManager.AddSlide(new CutsceneManager.CutsceneSlide(_outroSlides[6],
                "But today... today we celebrate the dawn.",
                dur + 3000, 1.1f, 1.1f, new Vector2(-30, -30), new Vector2(30, 30)));

            _currentState = GameState.Outro;
        }

        private void DrawLevelUpScreen()
        {
            _spriteBatch.Draw(_uiPixel, GraphicsDevice.Viewport.Bounds, Color.Black * 0.7f);

            string title = "ALTERNATE PHYSICS WITH THE STRENGTH OF THE DEAD";
            Vector2 size = _uiFont.MeasureString(title);
            _spriteBatch.DrawString(_uiFont, title, new Vector2(GraphicsDevice.Viewport.Width / 2 - size.X / 2, 100), Color.Gold);

            Rectangle screen = GraphicsDevice.Viewport.Bounds;
            int cardWidth = 200;
            int cardHeight = 300;
            int spacing = 50;
            int totalWidth = (_currentUpgradeOptions.Count * cardWidth) + ((_currentUpgradeOptions.Count - 1) * spacing);
            int startX = (screen.Width / 2) - (totalWidth / 2);
            int startY = (screen.Height / 2) - (cardHeight / 2);

            Point mousePos = Mouse.GetState().Position;

            for (int i = 0; i < _currentUpgradeOptions.Count; i++)
            {
                Rectangle cardRect = new Rectangle(startX + (i * (cardWidth + spacing)), startY, cardWidth, cardHeight);
                bool hover = cardRect.Contains(mousePos);
                _upgradeManager.DrawCard(_spriteBatch, cardRect, _currentUpgradeOptions[i], hover, _uiFont);
            }
        }

        private void DrawEndScreen(bool victory)
        {
            _spriteBatch.Draw(_uiPixel, GraphicsDevice.Viewport.Bounds, Color.Black * 0.85f);

            string title = victory ? "VICTORY" : "YOU DIED";
            Color color = victory ? Color.Gold : Color.Red;

            Vector2 size = _uiFont.MeasureString(title);
            Vector2 center = new Vector2(GraphicsDevice.Viewport.Width / 2, GraphicsDevice.Viewport.Height / 2);

            _spriteBatch.DrawString(_uiFont, title, new Vector2(center.X - size.X, center.Y - 150), color, 0f, Vector2.Zero, 2.0f, SpriteEffects.None, 0f);

            if (victory)
            {
                string lore = "The Skeleton King is defeated.\nThe Pale Roots recede.";
                Vector2 loreSize = _uiFont.MeasureString(lore);
                _spriteBatch.DrawString(_uiFont, lore, new Vector2(center.X - loreSize.X / 2, center.Y - 80), Color.White);
            }

            Rectangle btn1Rect = new Rectangle((int)center.X - 100, (int)center.Y, 200, 50);
            Rectangle btn2Rect = new Rectangle((int)center.X - 100, (int)center.Y + 70, 200, 50);

            Point mousePos = Mouse.GetState().Position;

            void DrawBtn(Rectangle r, string t)
            {
                bool hover = r.Contains(mousePos);
                _spriteBatch.Draw(_uiPixel, r, hover ? Color.Gray : Color.DarkGray);

                int b = 2;
                Color bc = hover ? Color.White : Color.Black;
                _spriteBatch.Draw(_uiPixel, new Rectangle(r.X, r.Y, r.Width, b), bc);
                _spriteBatch.Draw(_uiPixel, new Rectangle(r.X, r.Bottom - b, r.Width, b), bc);
                _spriteBatch.Draw(_uiPixel, new Rectangle(r.X, r.Y, b, r.Height), bc);
                _spriteBatch.Draw(_uiPixel, new Rectangle(r.Right - b, r.Y, b, r.Height), bc);

                Vector2 ts = _uiFont.MeasureString(t);
                _spriteBatch.DrawString(_uiFont, t, new Vector2(r.Center.X - ts.X / 2, r.Center.Y - ts.Y / 2), Color.White);
            }

            string btn1Text = victory ? "FINISH GAME" : "PLAY AGAIN";

            DrawBtn(btn1Rect, btn1Text);
            DrawBtn(btn2Rect, "QUIT");
        }

        protected override void Draw(GameTime gameTime)
        {
            GraphicsDevice.Clear(Color.Black);

            switch (_currentState)
            {
                case GameState.Intro:
                    _spriteBatch.Begin();
                    _cutsceneManager.Draw(_spriteBatch, GraphicsDevice.Viewport.Width, GraphicsDevice.Viewport.Height);
                    _spriteBatch.End();
                    break;

                case GameState.Gameplay:
                    _spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.PointClamp, null, null, null, _gameEngine._camera.CurrentCameraTranslation);
                    _gameEngine.Draw(gameTime, _spriteBatch);
                    _spriteBatch.End();

                    _spriteBatch.Begin();
                    DrawHUD();
                    _spriteBatch.End();
                    break;

                case GameState.Credits:
                    _spriteBatch.Begin();
                    GraphicsDevice.Clear(Color.Black);

                    string[] lines = _creditsText.Split('\n');
                    float currentY = _creditsScrollY;
                    float lineHeight = _uiFont.LineSpacing;

                    foreach (string line in lines)
                    {
                        if (!string.IsNullOrWhiteSpace(line))
                        {
                            Vector2 lineSize = _uiFont.MeasureString(line);
                            Vector2 linePos = new Vector2(
                                (GraphicsDevice.Viewport.Width / 2) - (lineSize.X / 2),
                                currentY
                            );
                            _spriteBatch.DrawString(_uiFont, line, linePos, Color.White);
                        }
                        currentY += lineHeight;
                    }
                    _spriteBatch.End();
                    break;

                case GameState.LevelUp:
                case GameState.Victory:
                case GameState.GameOver:
                    _spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.PointClamp, null, null, null, _gameEngine._camera.CurrentCameraTranslation);
                    _gameEngine.Draw(gameTime, _spriteBatch);
                    _spriteBatch.End();

                    _spriteBatch.Begin();
                    if (_currentState == GameState.LevelUp) DrawLevelUpScreen();
                    else DrawEndScreen(_currentState == GameState.Victory);
                    _spriteBatch.End();
                    break;

                case GameState.Outro:
                    _spriteBatch.Begin();
                    _cutsceneManager.Draw(_spriteBatch, GraphicsDevice.Viewport.Width, GraphicsDevice.Viewport.Height);
                    _spriteBatch.End();
                    break;

                case GameState.Menu:
                    _spriteBatch.Begin();
                    if (_menuBackground != null)
                    {
                        _spriteBatch.Draw(_menuBackground, new Rectangle(0, 0, GraphicsDevice.Viewport.Width, GraphicsDevice.Viewport.Height), Color.White);
                    }
                    else
                    {
                        _spriteBatch.End();
                        _spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.PointClamp, null, null, null, _gameEngine._camera.CurrentCameraTranslation);
                        _gameEngine.Draw(gameTime, _spriteBatch);
                        _spriteBatch.End();
                        _spriteBatch.Begin();
                    }
                    DrawMenu();
                    _spriteBatch.End();
                    break;
            }
            base.Draw(gameTime);
        }

        private void DrawHUD()
        {
            Player p = _gameEngine.GetPlayer();
            if (p == null) return;

            int padding = 20;
            int barHeight = 25;
            int barWidth = 300;

            _spriteBatch.Draw(_uiPixel, new Rectangle(padding, padding, barWidth + 4, (barHeight * 2) + 15), _hudColor);

            float hpPercent = (float)p.Health / p.MaxHealth;
            _spriteBatch.Draw(_uiPixel, new Rectangle(padding + 2, padding + 2, barWidth, barHeight), Color.Black * 0.5f);
            _spriteBatch.Draw(_uiPixel, new Rectangle(padding + 2, padding + 2, (int)(barWidth * hpPercent), barHeight), _healthColor);

            float dashRatio = 0f;
            if (p.DashDuration > 0) dashRatio = 1.0f - (p.DashTimer / p.DashDuration);
            else dashRatio = 1.0f;
            dashRatio = MathHelper.Clamp(dashRatio, 0f, 1f);

            int stamY = padding + barHeight + 8;
            int stamH = barHeight / 2;
            _spriteBatch.Draw(_uiPixel, new Rectangle(padding + 2, stamY, barWidth, stamH), Color.Black * 0.5f);
            Color currentStaminaColor = (dashRatio >= 0.99f) ? _staminaColor : Color.Orange;
            _spriteBatch.Draw(_uiPixel, new Rectangle(padding + 2, stamY, (int)(barWidth * dashRatio), stamH), currentStaminaColor);

            int screenW = GraphicsDevice.Viewport.Width;
            int barW = 600;
            int barH = 20;
            int barX = (screenW / 2) - (barW / 2);
            int barY = 20;

            _spriteBatch.Draw(_uiPixel, new Rectangle(barX - 2, barY - 2, barW + 4, barH + 4), Color.Black);
            _spriteBatch.Draw(_uiPixel, new Rectangle(barX, barY, barW, barH), Color.DarkGray * 0.5f);

            float progress = (float)_gameEngine.EnemiesKilled / WIN_CONDITION_KILLS;
            if (progress > 1f) progress = 1f;
            _spriteBatch.Draw(_uiPixel, new Rectangle(barX, barY, (int)(barW * progress), barH), Color.Purple);

            string warText = "WAR DOMINANCE";
            Vector2 textSize = _uiFont.MeasureString(warText);
            _spriteBatch.DrawString(_uiFont, warText, new Vector2(screenW / 2 - textSize.X / 2, barY + barH + 5), Color.White);

            int iconSize = 64;
            int spacing = 20;
            int startY = GraphicsDevice.Viewport.Height - iconSize - 20;

            int unlockedSpells = 0;
            for (int i = 0; i < 6; i++) if (_gameEngine.GetSpellManager().IsSpellUnlocked(i)) unlockedSpells++;

            bool showDash = p.IsDashUnlocked;
            bool showHeavy = p.IsHeavyAttackUnlocked;

            int totalItems = unlockedSpells + (showDash ? 1 : 0) + (showHeavy ? 1 : 0);

            if (totalItems > 0)
            {
                int totalWidth = (totalItems * iconSize) + ((totalItems - 1) * spacing);
                int currentX = (screenW / 2) - (totalWidth / 2);

                Rectangle bgRect = new Rectangle(currentX - 10, startY - 10, totalWidth + 20, iconSize + 20);
                _spriteBatch.Draw(_uiPixel, bgRect, Color.Black * 0.6f);

                if (showDash)
                {
                    Rectangle dest = new Rectangle(currentX, startY, iconSize, iconSize);
                    _spriteBatch.Draw(_dashIcon, dest, Color.White);
                    _spriteBatch.DrawString(_uiFont, "SHFT", new Vector2(dest.X + 2, dest.Y + 2), Color.Gold, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);

                    if (p.DashTimer > 0)
                    {
                        float ratio = p.DashTimer / p.DashDuration;
                        int h = (int)(iconSize * ratio);
                        Rectangle cdRect = new Rectangle(dest.X, dest.Bottom - h, iconSize, h);
                        _spriteBatch.Draw(_uiPixel, cdRect, Color.Black * 0.7f);
                    }
                    currentX += iconSize + spacing;
                }

                if (showHeavy)
                {
                    Rectangle dest = new Rectangle(currentX, startY, iconSize, iconSize);
                    _spriteBatch.Draw(_heavyAttackIcon, dest, Color.White);
                    _spriteBatch.DrawString(_uiFont, "R-CLK", new Vector2(dest.X + 2, dest.Y + 2), Color.Gold, 0f, Vector2.Zero, 0.7f, SpriteEffects.None, 0f);
                    currentX += iconSize + spacing;
                }

                for (int i = 0; i < 6; i++)
                {
                    if (_gameEngine.GetSpellManager().IsSpellUnlocked(i))
                    {
                        Rectangle dest = new Rectangle(currentX, startY, iconSize, iconSize);

                        if (_spellIcons[i] != null)
                            _spriteBatch.Draw(_spellIcons[i], dest, Color.White);

                        string key = (i + 1).ToString();
                        _spriteBatch.DrawString(_uiFont, key, new Vector2(dest.X + 2, dest.Y + 2), Color.Gold);

                        Spell s = _gameEngine.GetSpellManager().GetSpell(i);
                        if (s != null && s.CurrentCooldown > 0)
                        {
                            float ratio = s.CurrentCooldown / s.CooldownDuration;
                            int h = (int)(iconSize * ratio);

                            Rectangle cdRect = new Rectangle(dest.X, dest.Bottom - h, iconSize, h);
                            _spriteBatch.Draw(_uiPixel, cdRect, Color.Black * 0.7f);

                            if (s.CurrentCooldown > 1000)
                            {
                                string sec = (s.CurrentCooldown / 1000).ToString("0");
                                Vector2 sz = _uiFont.MeasureString(sec);
                                _spriteBatch.DrawString(_uiFont, sec,
                                    new Vector2(dest.Center.X - sz.X / 2, dest.Center.Y - sz.Y / 2), Color.White);
                            }
                        }

                        currentX += iconSize + spacing;
                    }
                }
            }
        }

        private void DrawMenu()
        {
            int screenW = GraphicsDevice.Viewport.Width;
            int screenH = GraphicsDevice.Viewport.Height;

            _spriteBatch.Draw(_uiPixel, new Rectangle(0, 0, screenW, screenH), Color.Black * 0.6f);

            Point mousePoint = new Point(Mouse.GetState().X, Mouse.GetState().Y);

            void DrawFancyButton(Rectangle rect, string text, bool isHovered)
            {
                Color fillColor = isHovered ? _btnHover : _btnNormal;
                Color borderColor = isHovered ? _borderHover : _borderNormal;

                _spriteBatch.Draw(_uiPixel, rect, fillColor);

                int borderThickness = 2;
                _spriteBatch.Draw(_uiPixel, new Rectangle(rect.X, rect.Y, rect.Width, borderThickness), borderColor);
                _spriteBatch.Draw(_uiPixel, new Rectangle(rect.X, rect.Bottom - borderThickness, rect.Width, borderThickness), borderColor);
                _spriteBatch.Draw(_uiPixel, new Rectangle(rect.X, rect.Y, borderThickness, rect.Height), borderColor);
                _spriteBatch.Draw(_uiPixel, new Rectangle(rect.Right - borderThickness, rect.Y, borderThickness, rect.Height), borderColor);

                if (_uiFont != null)
                {
                    Vector2 size = _uiFont.MeasureString(text);
                    Vector2 pos = new Vector2(rect.Center.X - size.X / 2, rect.Center.Y - size.Y / 2);
                    _spriteBatch.DrawString(_uiFont, text, pos, Color.White);
                }
            }

            bool playHover = _playBtnRect.Contains(mousePoint);
            DrawFancyButton(_playBtnRect, _hasStarted ? "RESUME" : "PLAY", playHover);

            bool quitHover = _quitBtnRect.Contains(mousePoint);
            DrawFancyButton(_quitBtnRect, "QUIT", quitHover);

            if (_uiFont != null)
            {
                string title = "PALE ROOTS";
                Vector2 titleSize = _uiFont.MeasureString(title);
                Vector2 titlePos = new Vector2(screenW / 2f, 200);
                Vector2 origin = titleSize / 2f;

                _spriteBatch.DrawString(_uiFont, title, titlePos + new Vector2(3, 3), Color.Black * 0.8f, 0f, origin, 2.5f, SpriteEffects.None, 0f);
                _spriteBatch.DrawString(_uiFont, title, titlePos, Color.PaleGoldenrod, 0f, origin, 2.5f, SpriteEffects.None, 0f);
            }
        }
    }
}
namespace Pale_Roots_1
{
    public enum GameState
    {
        Intro,
        Menu,
        Gameplay,
        LevelUp,
        Victory,
        Outro,
        Credits,
        GameOver
    }
}
using System.Collections.Generic;
using Microsoft.Xna.Framework;

namespace Pale_Roots_1
{
    public class Level
    {
        public int[,] MapLayout { get; set; }
        public List<TileRef> TilePalette { get; set; }
        public Vector2 PlayerStartPos { get; set; }

        public enum TileType
        {
            Floor= 0,
            Wall = 1,
            Tree = 2,

        }

        public Level(int[,] map, List<TileRef> tiles, Vector2 startPos)
        {
            MapLayout = map;
            TilePalette = tiles;
            PlayerStartPos = startPos;
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    public class LevelManager
    {
        private Game _game;
        private List<Level> _allLevels = new List<Level>();

        // --- ENTITY LISTS ---
        public List<Enemy> enemies = new List<Enemy>();
        public List<WorldObject> MapObjects = new List<WorldObject>();

        // --- GRAPHICS ---
        public TileLayer CurrentLevel { get; private set; }
        private Texture2D _groundSheet;
        private Texture2D _animatedObjectSheet;
        private Texture2D _staticObjectSheet;


        private string[] _natureObjects = {
            "Dying_Tree", "Medium_Dying_Tree", "Small_Dying_Tree",
            "Brambles_Large", "Brambles_Medium", "Brambles_Small",
            "Brambles_Tiny", "Brambles_Very_Tiny"
        };

        private string[] _graveObjects = {
            "Grave_1", "Grave_2", "Grave_3",
            "Hand_In_Floor", "Hand_In_Floor_Medium", "Hand_In_Floor_Small"
        };

        private string[] _ruinObjects = {
            "Ruins_Column", "Smaller_Ruin", "Big_Rock", "Shrine_Blue"
        };

        private string[] _boneObjects = {
            "Skull_Pile", "Ribcage", "Bone_In_Floor", "Bird_Skull",
            "Baby_Skellington"
        };

        public LevelManager(Game game)
        {
            _game = game;
            // We don't initialize here anymore, we do it in LoadLevel to be safe
        }

        public void LoadLevel(int index)
        {
            _groundSheet = _game.Content.Load<Texture2D>("MainLev2.0");

            _animatedObjectSheet = _game.Content.Load<Texture2D>("Objects_animated");
            _staticObjectSheet = _game.Content.Load<Texture2D>("more Objects");

            Helper.SpriteSheet = _groundSheet;

            InitializeGameWorld();
        }

        private void InitializeGameWorld()
        {

            int width = 60;
            int height = 34;
            int[,] map = new int[height, width];

            // 2. CREATE FLOOR
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    map[y, x] = 0;
                }
            }

          
            List<TileRef> palette = new List<TileRef>();
            palette.Add(new TileRef(13, 41, 0));
            palette.Add(new TileRef(14, 41, 0));
            palette.Add(new TileRef(15, 41, 0));
            palette.Add(new TileRef(16, 41, 0));
            palette.Add(new TileRef(17, 41, 0));
            palette.Add(new TileRef(13, 42, 0));
            palette.Add(new TileRef(14, 42, 0));
            palette.Add(new TileRef(15, 42, 0));
            palette.Add(new TileRef(16, 42, 0));
            palette.Add(new TileRef(17, 42, 0));
            palette.Add(new TileRef(13, 43, 0));
            palette.Add(new TileRef(14, 43, 0));
            palette.Add(new TileRef(15, 43, 0));
            palette.Add(new TileRef(16, 43, 0));
            palette.Add(new TileRef(17, 43, 0));
            palette.Add(new TileRef(13, 44, 0));
            palette.Add(new TileRef(14, 44, 0));
            palette.Add(new TileRef(15, 44, 0));
            palette.Add(new TileRef(16, 44, 0));
            palette.Add(new TileRef(17, 44, 0));
            palette.Add(new TileRef(13, 45, 0));
            palette.Add(new TileRef(14, 45, 0));
            palette.Add(new TileRef(15, 45, 0));
            palette.Add(new TileRef(16, 45, 0));
            palette.Add(new TileRef(17, 45, 0));
            palette.Add(new TileRef(13, 46, 0));
            palette.Add(new TileRef(14, 46, 0));
            palette.Add(new TileRef(15, 46, 0));
            palette.Add(new TileRef(16, 46, 0));
            palette.Add(new TileRef(17, 46, 0));
            palette.Add(new TileRef(13, 47, 0));
            palette.Add(new TileRef(14, 47, 0));
            palette.Add(new TileRef(15, 47, 0));
            palette.Add(new TileRef(16, 47, 0));
            palette.Add(new TileRef(17, 47, 0));
            palette.Add(new TileRef(13, 48, 0));
            palette.Add(new TileRef(14, 48, 0));
            palette.Add(new TileRef(15, 48, 0));
            palette.Add(new TileRef(16, 48, 0));
            palette.Add(new TileRef(17, 48, 0));

            palette.Add(new TileRef(9, 42, 0));
            palette.Add(new TileRef(10, 42, 0));
            palette.Add(new TileRef(11, 42, 0));
            palette.Add(new TileRef(12, 42, 0));
            palette.Add(new TileRef(9, 43, 0));
            palette.Add(new TileRef(10, 43, 0));
            palette.Add(new TileRef(11, 43, 0));
            palette.Add(new TileRef(12, 43, 0));
            //palette.Add(new TileRef(9, 44, 0)); 
            //palette.Add(new TileRef(10, 44, 0));
            //palette.Add(new TileRef(11, 44, 0));
            //palette.Add(new TileRef(12, 44, 0));

            palette.Add(new TileRef(9, 46, 0));
            palette.Add(new TileRef(10, 46, 0));
            palette.Add(new TileRef(11, 46, 0));
            palette.Add(new TileRef(12, 46, 0));
            palette.Add(new TileRef(9, 47, 0));
            palette.Add(new TileRef(10, 47, 0));
            palette.Add(new TileRef(11, 47, 0));
            palette.Add(new TileRef(12, 47, 0));
            palette.Add(new TileRef(9, 48, 0));
            palette.Add(new TileRef(10, 48, 0));
            palette.Add(new TileRef(11, 48, 0));
            palette.Add(new TileRef(12, 48, 0));


            CurrentLevel = new TileLayer(map, palette, 64, 32);



            float centerX = width / 2f;
            float centerY = height / 2f;

            float safeRadiusX = 22f;
            float safeRadiusY = 11f;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {

                    float dx = Math.Abs(x - centerX);
                    float dy = Math.Abs(y - centerY);

                    float excessX = Math.Max(dx - safeRadiusX, 0);
                    float excessY = Math.Max(dy - safeRadiusY, 0);

                    float distanceOutsideBox = (float)Math.Sqrt(excessX * excessX + excessY * excessY);

                    if (distanceOutsideBox > 0)
                    {
                        float chance = distanceOutsideBox / 4.5f;


                        chance += CombatSystem.RandomFloat(-0.2f, 0.2f);

                        if (CombatSystem.RandomFloat() < chance)
                        {
                            Vector2 pos = new Vector2(x * 64, y * 64);

   
                            pos.X += CombatSystem.RandomInt(-24, 24);
                            pos.Y += CombatSystem.RandomInt(-24, 24);


                            string randomNature = _natureObjects[CombatSystem.RandomInt(0, _natureObjects.Length)];

                            CreateStaticObject(randomNature, pos, _staticObjectSheet, false);
                        }
                    }
                }
            }

            PlaceLandMarks();
        }
        //private void PlaceLandMarks()
        //{
        //    // Animated objects are fine as they were
        //    Vector2 centerPos = new Vector2(30 * 64, 17 * 64);
        //    CreateAnimatedObject("Tree_Dead_Large", centerPos, _animatedObjectSheet, 4);

        //    Vector2 topRightPos = new Vector2(45 * 64, 5 * 64);

        //    // CHANGE: Columns and Rocks are solid (true)
        //    CreateStaticObject("Ruins_Column", topRightPos, _staticObjectSheet, true);
        //    CreateStaticObject("Big_Rock", topRightPos + new Vector2(50, 50), _staticObjectSheet, true);

        //    Vector2 bottomLeftPos = new Vector2(15 * 64, 28 * 64);
        //    CreateStaticObject("Ruins_Column", bottomLeftPos, _staticObjectSheet, true);

        //    Vector2 ringCenter = new Vector2(45 * 64, 25 * 64);
        //    int radius = 150;
        //    int skullCount = 8;

        //    for (int i = 0; i < skullCount; i++)
        //    {
        //        float angle = i * (MathHelper.TwoPi / skullCount);
        //        Vector2 offset = new Vector2((float)Math.Cos(angle) * radius, (float)Math.Sin(angle) * radius);


        //        CreateStaticObject("Skull_Pile", ringCenter + offset, _staticObjectSheet, false);
        //    }

        //    for (int i = 0; i < 15; i++)
        //    {
        //        int rx = CombatSystem.RandomInt(10, 50);
        //        int ry = CombatSystem.RandomInt(5, 29);
        //        Vector2 pos = new Vector2(rx * 64, ry * 64);

        //        if (CombatSystem.RandomInt(0, 100) > 50)

        //            CreateStaticObject("Big_Rock", pos, _staticObjectSheet, true);
        //        else

        //            CreateStaticObject("Hand_In_Floor", pos, _staticObjectSheet, false);
        //    }
        //}
        private bool IsSpaceOccupied(Vector2 pos, float minGap)
        {
            foreach (var obj in MapObjects)
            {

                float objectRadius = (obj.spriteWidth * (float)obj.Scale) / 2.5f;

                float safeDistance = minGap + objectRadius;

                // 3. Check distance
                if (Vector2.Distance(pos, obj.position) < safeDistance)
                {
                    return true; // Too close!
                }
            }
            return false;
        }
        //private void PlaceLandMarks()
        //{
        //    // ==========================================
        //    // 1. FIXED LANDMARKS (Spawn these FIRST)
        //    // ==========================================

        //    // Center Tree
        //    Vector2 centerPos = new Vector2(30 * 64, 17 * 64);
        //    CreateAnimatedObject("Tree_Dead_Large", centerPos, _animatedObjectSheet, 4);

        //    // Skeleton King (Right, slightly Up)
        //    Vector2 kingPos = new Vector2(42 * 64, 14 * 64);
        //    CreateStaticObject("Skellington", kingPos, _staticObjectSheet, false);

        //    // Big Ruin (Top Right)
        //    Vector2 bigRuinPos = new Vector2(52 * 64, 6 * 64);
        //    CreateStaticObject("Ruins_Column", bigRuinPos, _staticObjectSheet, false);
        //    CreateStaticObject("Big_Rock", bigRuinPos + new Vector2(-60, 20), _staticObjectSheet, false);
        //    CreateStaticObject("Ruins_Column", bigRuinPos + new Vector2(50, 40), _staticObjectSheet, false);

        //    // Smaller Ruin (Bottom Right)
        //    Vector2 smallRuinPos = new Vector2(50 * 64, 28 * 64);
        //    CreateStaticObject("Smaller_Ruin", smallRuinPos, _staticObjectSheet, false);


        //    // ==========================================
        //    // 2. THE GRAVEYARD (Left Side Only)
        //    // ==========================================
        //    int gravesPlaced = 0;
        //    int attempts = 0;

        //    while (gravesPlaced < 25 && attempts < 200)
        //    {
        //        attempts++;

        //        // Random Position on Left Side
        //        int gx = CombatSystem.RandomInt(4, 22);
        //        int gy = CombatSystem.RandomInt(4, 30);
        //        Vector2 gravePos = new Vector2(gx * 64, gy * 64);

        //        // CHECK: Increased gap to 80f (more than 1 tile width)
        //        if (IsSpaceOccupied(gravePos, 80f)) continue;

        //        string graveName = (CombatSystem.RandomInt(0, 2) == 0) ? "Grave_1" : "Grave_2";
        //        CreateStaticObject(graveName, gravePos, _staticObjectSheet, false);
        //        gravesPlaced++;
        //    }


        //    // ==========================================
        //    // 3. SKELETAL REMAINS CIRCLE (Around Tree)
        //    // ==========================================
        //    string[] bones = { "Skull_Pile", "Ribcage", "Bone_In_Floor", "Bird_Skull" };
        //    int boneCount = 12;
        //    float radius = 400f;

        //    for (int i = 0; i < boneCount; i++)
        //    {
        //        float angle = i * (MathHelper.TwoPi / boneCount);
        //        float jitter = CombatSystem.RandomFloat(-0.5f, 0.5f);
        //        float distJitter = CombatSystem.RandomInt(-50, 50);

        //        Vector2 offset = new Vector2(
        //            (float)Math.Cos(angle + jitter) * (radius + distJitter),
        //            (float)Math.Sin(angle + jitter) * (radius + distJitter)
        //        );
        //        Vector2 finalPos = centerPos + offset;

        //        // CHECK: Gap of 60f for bones
        //        if (IsSpaceOccupied(finalPos, 60f)) continue;

        //        string boneItem = bones[CombatSystem.RandomInt(0, bones.Length)];
        //        CreateStaticObject(boneItem, finalPos, _staticObjectSheet, false);
        //    }


        //    // ==========================================
        //    // 4. RANDOM SCATTER (Hands, Dead Trees)
        //    // ==========================================
        //    int scatterPlaced = 0;
        //    attempts = 0;

        //    while (scatterPlaced < 15 && attempts < 200)
        //    {
        //        attempts++;

        //        int rx = CombatSystem.RandomInt(5, 55);
        //        int ry = CombatSystem.RandomInt(5, 29);
        //        Vector2 pos = new Vector2(rx * 64, ry * 64);

        //        // Don't spawn too close to center tree
        //        if (Vector2.Distance(pos, centerPos) < 300) continue;

        //        // CHECK: Increased gap to 100f so random trees don't clump
        //        if (IsSpaceOccupied(pos, 100f)) continue;

        //        if (CombatSystem.RandomInt(0, 100) > 50)
        //        {
        //            string randomTree = _treeTypes[CombatSystem.RandomInt(0, _treeTypes.Length)];
        //            CreateStaticObject(randomTree, pos, _staticObjectSheet, false);
        //        }
        //        else
        //        {
        //            string randomHand = _floorDetails[CombatSystem.RandomInt(0, _floorDetails.Length)];
        //            CreateStaticObject(randomHand, pos, _staticObjectSheet, false);
        //        }


        //        scatterPlaced++;
        //    }
        //}

        private void PlaceLandMarks()
        {

            Vector2 centerPos = new Vector2(30 * 64, 17 * 64);
            CreateAnimatedObject("Tree_Dead_Large", centerPos, _animatedObjectSheet, 4);

            Vector2 kingPos = new Vector2(40 * 64, 16 * 64);
            CreateStaticObject("Skellington", kingPos, _staticObjectSheet, true); // Solid!


            Vector2 bigRuinPos = new Vector2(8 * 64, 6 * 64);
            CreateStaticObject("Ruins_Column", bigRuinPos, _staticObjectSheet, true);
            CreateStaticObject("Big_Rock", bigRuinPos + new Vector2(200, 190), _staticObjectSheet, true);

            CreateStaticObject("Smaller_Ruin", new Vector2(50 * 64, 7 * 64), _staticObjectSheet, true);
            CreateStaticObject("Smaller_Ruin", new Vector2(48 * 64, 26 * 64), _staticObjectSheet, true);

            FillZones(centerPos);
        }
        private void FillZones(Vector2 centerPos)
        {
            int attempts = 0;
            int maxItems = 60; 
            int itemsPlaced = 0;

            while (itemsPlaced < maxItems && attempts < 1000)
            {
                attempts++;

                int tx = CombatSystem.RandomInt(6, 54);
                int ty = CombatSystem.RandomInt(6, 28);
                Vector2 pos = new Vector2(tx * 64, ty * 64);

                pos += new Vector2(CombatSystem.RandomInt(-20, 20), CombatSystem.RandomInt(-20, 20));


                float distToCenter = Vector2.Distance(pos, centerPos);

                // 3. Check Collision (Don't spawn on top of the King or Ruins)
                // We use a large gap (80f) to ensure objects aren't clumped
                if (IsSpaceOccupied(pos, 80f)) continue;

                string assetToSpawn = "";
                bool isSolid = false;

                // --- ZONE LOGIC ---

                // ZONE A: The Bone Circle (Close to center tree)
                if (distToCenter < 350 && distToCenter > 100)
                {
                    assetToSpawn = _boneObjects[CombatSystem.RandomInt(0, _boneObjects.Length)];
                }
                // ZONE B: The Graveyard (Left side of map: X < 20)
                else if (tx < 22)
                {
                    assetToSpawn = _graveObjects[CombatSystem.RandomInt(0, _graveObjects.Length)];
                    // Graves are usually solid, hands are not. 
                    // Simple check: if it starts with "Grave", it's solid.
                    if (assetToSpawn.StartsWith("Grave")) isSolid = true;
                }
                // ZONE C: The Ruins/Scatter (Right side: X > 38)
                else if (tx > 38)
                {
                    // Mix of rocks and ruins
                    if (CombatSystem.RandomInt(0, 100) > 70)
                        assetToSpawn = _ruinObjects[CombatSystem.RandomInt(0, _ruinObjects.Length)];
                    else
                        assetToSpawn = _natureObjects[CombatSystem.RandomInt(0, _natureObjects.Length)];

                    isSolid = true;
                }
                // ZONE D: General Open Space (Everywhere else)
                else
                {
                    // Sparse random details (Bones or small plants)
                    if (CombatSystem.RandomInt(0, 100) > 50)
                        assetToSpawn = _boneObjects[CombatSystem.RandomInt(0, _boneObjects.Length)];
                    else
                        assetToSpawn = _natureObjects[CombatSystem.RandomInt(0, _natureObjects.Length)];
                }

                // 4. Create the object
                if (assetToSpawn != "")
                {

                    if (IsTooCloseToIdentical(assetToSpawn, pos, 500f))
                    {

                        continue;
                    }

                    CreateStaticObject(assetToSpawn, pos, _staticObjectSheet, isSolid);
                    itemsPlaced++;
                }
            }
        }
        private bool IsTooCloseToIdentical(string assetName, Vector2 pos, float minDistance)
        {
            foreach (var obj in MapObjects)
            {
                // 1. Is it the exact same object type?
                if (obj.AssetName == assetName)
                {
                    // 2. Is it too close?
                    if (Vector2.Distance(pos, obj.position) < minDistance)
                    {
                        return true; // Yes, reject this spawn
                    }
                }
            }
            return false; // No twins found nearby
        }
        private void CreateStaticObject(string assetName, Vector2 position, Texture2D sheet, bool isSolid)
        {
            Rectangle data = Helper.GetSourceRect(assetName);

            var obj = new WorldObject(_game, sheet, position, 1, isSolid);

            obj.AssetName = assetName;

            obj.SetSpriteSheetLocation(data);
            MapObjects.Add(obj);
        }
        private void CreateAnimatedObject(string assetName, Vector2 position, Texture2D sheet, int frames)
        {
            Rectangle data = Helper.GetSourceRect(assetName);

            var obj = new WorldObject(_game, sheet, position, frames, false);

            obj.SetSpriteSheetLocation(data);

            MapObjects.Add(obj);
        }
        private Vector2 GetRandomPosition()
        {
            int tx = CombatSystem.RandomInt(2, 28);
            int ty = CombatSystem.RandomInt(2, 28);

            return new Vector2((tx * 64) + 32, (ty * 64) + 32);
        }

        public void Update(GameTime gameTime, Player player)
        {
            // Update Enemies
            foreach (Enemy enemy in enemies)
            {
                enemy.CurrentCombatPartner = player;
                enemy.Update(gameTime);
            }
            enemies.RemoveAll(e => e.LifecycleState == Enemy.ENEMYSTATE.DEAD);

            // Update Map Objects (Animations)
            foreach (var obj in MapObjects)
            {
                obj.Update(gameTime);
            }
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            // Only draw the floor tiles here. 
            // Objects are drawn in ChaseAndFireEngine to get the depth sorting!
            if (CurrentLevel != null)
            {
                CurrentLevel.Draw(spriteBatch);
            }
        }
    }
}
using var game = new Pale_Roots_1.Game1();
game.Run();
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    public abstract class Spell
    {
        public string Name { get; protected set; }
        public float CooldownDuration { get; protected set; }
        public float CurrentCooldown { get; set; } = 0f;

        public float ActiveDuration { get; protected set; }
        public float CurrentActiveTimer { get; set; } = 0f;
        public bool IsActive { get; protected set; } = false;

        // NEW: Allow spells to define their own size
        public float Scale { get; set; } = 3.0f;

        protected Game _game;
        protected AnimationManager _animManager;
        protected Vector2 _position;
        protected ChaseAndFireEngine _engineRef;

        public Spell(Game game)
        {
            _game = game;
            _animManager = new AnimationManager();
        }

        public virtual void Update(GameTime gameTime)
        {
            float dt = (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            if (CurrentCooldown > 0) CurrentCooldown -= dt;

            if (IsActive)
            {
                CurrentActiveTimer -= dt;
                _animManager.Update(gameTime);
                OnUpdateActive(gameTime);

                if (CurrentActiveTimer <= 0)
                {
                    EndEffect();
                }
            }
        }

        public virtual void Draw(SpriteBatch spriteBatch)
        {
            if (IsActive)
            {
                // FIX: Use the variable Scale instead of hardcoded 3.0f
                _animManager.Draw(spriteBatch, _position, Scale, SpriteEffects.None);
            }
        }

        public bool Cast(ChaseAndFireEngine engine, Vector2 targetPos)
        {
            if (CurrentCooldown > 0 || IsActive) return false;

            _engineRef = engine;
            CurrentCooldown = CooldownDuration;
            CurrentActiveTimer = ActiveDuration;
            IsActive = true;
            _position = targetPos;

            OnCast(engine);
            return true;
        }

        protected abstract void OnCast(ChaseAndFireEngine engine);
        protected virtual void EndEffect() { IsActive = false; }
        protected virtual void OnUpdateActive(GameTime gameTime) { }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // ==========================================
    // SPELL 1: SMITE
    // ==========================================
    public class SmiteSpell : Spell
    {
        public SmiteSpell(Game game, Texture2D sheet) : base(game)
        {
            Name = "Smite";
            CooldownDuration = 5000f;
            ActiveDuration = 1100f;
            Scale = 2.0f; // Slightly smaller than default

            _animManager.AddAnimation("Heal", new Animation(sheet, 11, 0, 100f, false, 1, 64));
            _animManager.Play("Heal");
        }

        protected override void OnCast(ChaseAndFireEngine engine)
        {
            Player p = engine.GetPlayer();
            p.Health += 100;
            if (p.Health > p.MaxHealth) p.Health = p.MaxHealth;
        }

        protected override void OnUpdateActive(GameTime gameTime)
        {
            if (_engineRef != null)
            {
                _position = _engineRef.GetPlayer().Position;
                _position.Y -= 30;
            }
        }
    }

    // ==========================================
    // SPELL 2: HOLY NOVA
    // ==========================================
    public class HolyNovaSpell : Spell
    {
        private float _radius = 250f;

        public HolyNovaSpell(Game game, Texture2D sheet) : base(game)
        {
            Name = "Holy Nova";
            CooldownDuration = 10000f;
            ActiveDuration = 1000f;
            Scale = 3.0f; // Keep big

            _animManager.AddAnimation("Explode", new Animation(sheet, 10, 0, 100f, false, 1, 128));
            _animManager.Play("Explode");
        }

        protected override void OnCast(ChaseAndFireEngine engine)
        {
            // --- NEW CODE ---
            List<Enemy> toKill = new List<Enemy>();

            // 1. Find enemies in range
            foreach (var enemy in engine._enemies)
            {
                if (Vector2.Distance(enemy.Position, _position) < _radius)
                {
                    toKill.Add(enemy);
                }
            }

            // 2. Deal massive damage
            foreach (var enemy in toKill)
            {
                CombatSystem.DealDamage(engine.GetPlayer(), enemy, 9999);
            }
        }
    }

    // ==========================================
    // SPELL 3: HEAVENS FURY
    // ==========================================
    public class HeavensFurySpell : Spell
    {
        private List<Vector2> _strikeLocations = new List<Vector2>();

        public HeavensFurySpell(Game game, Texture2D sheet) : base(game)
        {
            Name = "Heaven's Fury";
            CooldownDuration = 30000f;
            ActiveDuration = 15000f;
            Scale = 3.0f; // Keep big

            _animManager.AddAnimation("Cast", new Animation(sheet, 12, 0, 100f, true, 1, 128));
            _animManager.Play("Cast");
        }

        protected override void OnCast(ChaseAndFireEngine engine)
        {
            _strikeLocations.Clear();
            Vector2 center = engine.GetPlayer().Position;

            for (int i = 0; i < 10; i++)
            {
                float offX = CombatSystem.RandomInt(-900, 900);
                float offY = CombatSystem.RandomInt(-500, 500);
                _strikeLocations.Add(center + new Vector2(offX, offY));
            }

            foreach (var enemy in engine._enemies)
            {
                if (enemy.IsAlive) enemy.Health /= 2;
            }
            engine.GlobalEnemyHealthMult = 0.5f;
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            if (IsActive)
            {
                foreach (Vector2 loc in _strikeLocations)
                {
                    _animManager.Draw(spriteBatch, loc, Scale, SpriteEffects.None);
                }
            }
        }

        protected override void EndEffect()
        {
            base.EndEffect();
            if (_engineRef != null) _engineRef.GlobalEnemyHealthMult = 1.0f;
        }
    }

    // ==========================================
    // SPELL 4: HOLY SHIELD (FIXED SIZE)
    // ==========================================
    public class HolyShieldSpell : Spell
    {
        public HolyShieldSpell(Game game, Texture2D sheet) : base(game)
        {
            Name = "Holy Shield";
            CooldownDuration = 20000f;
            ActiveDuration = 15000f;

            // FIX: Reduced Scale so it isn't massive
            Scale = 1.5f;

            // FIX: Ensure width is 64 (standard tile)
            _animManager.AddAnimation("Shield", new Animation(sheet, 11, 0, 100f, true, 1, 64));
            _animManager.Play("Shield");
        }

        protected override void OnCast(ChaseAndFireEngine engine)
        {
            foreach (var ally in engine._allies)
            {
                if (ally.IsAlive) ally.Health *= 2;
            }
        }

        protected override void OnUpdateActive(GameTime gameTime)
        {
            if (_engineRef != null)
            {
                _position = _engineRef.GetPlayer().Position;
                _position.Y -= 30;
            }
        }
    }

    // ==========================================
    // SPELL 5: ELECTRICITY
    // ==========================================
    public class ElectricitySpell : Spell
    {
        private List<Vector2> _strikeLocations = new List<Vector2>();

        public ElectricitySpell(Game game, Texture2D sheet) : base(game)
        {
            Name = "Electricity";
            CooldownDuration = 40000f;
            ActiveDuration = 15000f;
            Scale = 3.0f;

            _animManager.AddAnimation("Storm", new Animation(sheet, 5, 0, 100f, true, 1, 128));
            _animManager.Play("Storm");
        }

        protected override void OnCast(ChaseAndFireEngine engine)
        {
            _strikeLocations.Clear();
            Vector2 center = engine.GetPlayer().Position;

            for (int i = 0; i < 10; i++)
            {
                float offX = CombatSystem.RandomInt(-900, 900);
                float offY = CombatSystem.RandomInt(-500, 500);
                _strikeLocations.Add(center + new Vector2(offX, offY));
            }

            engine.SpawningBlocked = true;
            foreach (var enemy in engine._enemies) enemy.IsStunned = true;
        }

        protected override void OnUpdateActive(GameTime gameTime)
        {
            if (_engineRef != null)
            {
                foreach (var enemy in _engineRef._enemies) enemy.IsStunned = true;
            }
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            if (IsActive)
            {
                foreach (Vector2 loc in _strikeLocations)
                {
                    _animManager.Draw(spriteBatch, loc, Scale, SpriteEffects.None);
                }
            }
        }

        protected override void EndEffect()
        {
            base.EndEffect();
            if (_engineRef != null)
            {
                _engineRef.SpawningBlocked = false;
                foreach (var enemy in _engineRef._enemies) enemy.IsStunned = false;
            }
        }
    }

    // ==========================================
    // SPELL 6: SWORD OF JUSTICE (FIXED DOUBLE IMAGE)
    // ==========================================
    public class SwordOfJusticeSpell : Spell
    {
        public SwordOfJusticeSpell(Game game, Texture2D sheet) : base(game)
        {
            Name = "Sword of Justice";
            CooldownDuration = 25000f;
            ActiveDuration = 15000f;

            // FIX 1: Reduced Scale
            Scale = 1.5f;

            // FIX 2: Changed width from 128 to 64. 
            // This stops it from grabbing 2 frames at once (the double image issue).
            _animManager.AddAnimation("Justice", new Animation(sheet, 5, 0, 200f, true, 1, 64));
            _animManager.Play("Justice");
        }

        protected override void OnCast(ChaseAndFireEngine engine)
        {
            engine.GlobalPlayerDamageMult = 2.0f;
        }

        protected override void OnUpdateActive(GameTime gameTime)
        {
            if (_engineRef != null)
            {
                _position = _engineRef.GetPlayer().Position;
                _position.Y -= 50;
            }
        }

        protected override void EndEffect()
        {
            base.EndEffect();
            if (_engineRef != null) _engineRef.GlobalPlayerDamageMult = 1.0f;
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    public class SpellManager
    {
        private ChaseAndFireEngine _engine;
        private List<Spell> _spells = new List<Spell>();

        private bool[] _unlockedSpells;

        // --- FIX IS HERE: NO "class" KEYWORD ---
        public SpellManager(ChaseAndFireEngine engine,
                            Texture2D smiteTx,
                            Texture2D novaTx,
                            Texture2D furyTx,
                            Texture2D shieldTx,
                            Texture2D electricTx,
                            Texture2D justiceTx)
        {
            _engine = engine;

            // Initialize Spells
            _spells.Add(new SmiteSpell(engine._gameOwnedBy, smiteTx));
            _spells.Add(new HolyNovaSpell(engine._gameOwnedBy, novaTx));
            _spells.Add(new HeavensFurySpell(engine._gameOwnedBy, furyTx));
            _spells.Add(new HolyShieldSpell(engine._gameOwnedBy, shieldTx));
            _spells.Add(new ElectricitySpell(engine._gameOwnedBy, electricTx));
            _spells.Add(new SwordOfJusticeSpell(engine._gameOwnedBy, justiceTx));

            _unlockedSpells = new bool[_spells.Count];
        }

        public void Update(GameTime gameTime)
        {
            foreach (var spell in _spells)
            {
                spell.Update(gameTime);
            }
            HandleInput();
        }

        private void HandleInput()
        {
            KeyboardState kState = Keyboard.GetState();
            MouseState mState = Mouse.GetState();
            Vector2 mouseScreenPos = new Vector2(mState.X, mState.Y);
            Matrix inverseTransform = Matrix.Invert(_engine._camera.CurrentCameraTranslation);
            Vector2 mousePos = Vector2.Transform(mouseScreenPos, inverseTransform);


            if (kState.IsKeyDown(Keys.D1)) CastSpell(0, mousePos);
            if (kState.IsKeyDown(Keys.D2)) CastSpell(1, mousePos);
            if (kState.IsKeyDown(Keys.D3)) CastSpell(2, mousePos);
            if (kState.IsKeyDown(Keys.D4)) CastSpell(3, mousePos);
            if (kState.IsKeyDown(Keys.D5)) CastSpell(4, mousePos);
            if (kState.IsKeyDown(Keys.D6)) CastSpell(5, mousePos);
        }

        private void CastSpell(int index, Vector2 target)
        {
            if (index >= 0 && index < _spells.Count)
            {
                if (_unlockedSpells[index])
                {
                    _spells[index].Cast(_engine, target);
                }
            }
        }
        public void UnlockSpell(int index)
        {
            if (index >= 0 && index < _unlockedSpells.Length)
            {
                _unlockedSpells[index] = true;
            }
        }

        public bool IsSpellUnlocked(int index)
        {
            if (index >= 0 && index < _unlockedSpells.Length) return _unlockedSpells[index];
            return false;
        }
        public Spell GetSpell(int index)
        {
            if (index >= 0 && index < _spells.Count)
            {
                return _spells[index];
            }
            return null;
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            foreach (var spell in _spells)
            {
                spell.Draw(spriteBatch);
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Pale_Roots_1
{
    public class UpgradeManager
    {
        public enum UpgradeType { HeavyAttack, Dash, Spell }

        public class UpgradeOption
        {
            public string Name;
            public string Description;
            public Texture2D Icon;
            public Action ApplyAction;
            public UpgradeType Type;
        }

        private Player _player;
        private SpellManager _spellManager;
        private Texture2D[] _spellIcons;

        private Texture2D _dashIcon;
        private Texture2D _heavyIcon;

        private Texture2D _pixel; // For card backgrounds

        // All possible upgrades in the game
        private List<UpgradeOption> _allUpgrades = new List<UpgradeOption>();

        public UpgradeManager(Player p, SpellManager sm, Texture2D[] icons, Texture2D dashIcon, Texture2D heavyIcon, GraphicsDevice gd)
        {
            _player = p;
            _spellManager = sm;
            _spellIcons = icons;

            // Store the new icons
            _dashIcon = dashIcon;
            _heavyIcon = heavyIcon;

            _pixel = new Texture2D(gd, 1, 1);
            _pixel.SetData(new[] { Color.White });

            InitializeUpgrades();
        }

        private void InitializeUpgrades()
        {
            // 1. Heavy Attack
            _allUpgrades.Add(new UpgradeOption
            {
                Name = "Heavy Attack",
                Description = "Right Click to deal double damage.",
                Type = UpgradeType.HeavyAttack,
                Icon = _heavyIcon,
                ApplyAction = () => _player.IsHeavyAttackUnlocked = true
            });

            // 2. Dash
            _allUpgrades.Add(new UpgradeOption
            {
                Name = "Dash",
                Description = "Press Shift to dodge attacks.",
                Type = UpgradeType.Dash,
                Icon = _dashIcon,
                ApplyAction = () => _player.IsDashUnlocked = true
            });

            // 3. Spells (Indices 0 to 5 based on SpellManager)
            string[] spellNames = { "Smite", "Holy Nova", "Heaven's Fury", "Holy Shield", "Electricity", "Sword of Justice" };
            string[] spellDescs = {
                "Heal yourself to full HP.",
                "Instakill AOE on your cursor",
                "Half Enemy Healthbars",
                "Double Ally Health",
                "Stun Enemies and stop spawning",
                "Double Damage"
            };

            for (int i = 0; i < 6; i++)
            {
                int index = i; // Capture for lambda
                _allUpgrades.Add(new UpgradeOption
                {
                    Name = spellNames[i],
                    Description = spellDescs[i],
                    Type = UpgradeType.Spell,
                    Icon = _spellIcons[i],
                    ApplyAction = () => _spellManager.UnlockSpell(index)
                });
            }
        }

        public List<UpgradeOption> GetRandomOptions(int count)
        {
            // Filter out upgrades we already have
            var available = _allUpgrades.Where(u => IsUpgradeAvailable(u)).ToList();

            // Shuffle
            var rng = new Random();
            int n = available.Count;
            while (n > 1)
            {
                n--;
                int k = rng.Next(n + 1);
                var value = available[k];
                available[k] = available[n];
                available[n] = value;
            }

            // Take top 3 (or fewer if we are running out)
            return available.Take(count).ToList();
        }

        private bool IsUpgradeAvailable(UpgradeOption u)
        {
            if (u.Type == UpgradeType.HeavyAttack) return !_player.IsHeavyAttackUnlocked;
            if (u.Type == UpgradeType.Dash) return !_player.IsDashUnlocked;

            // For spells, we need to check if the specific spell index is unlocked
            // We can infer the index from the name or store it. 
            // Since we initialized them in order 0-5:
            if (u.Type == UpgradeType.Spell)
            {
                // Find index in our spell list
                string[] spellNames = { "Smite", "Holy Nova", "Heaven's Fury", "Holy Shield", "Electricity", "Sword of Justice" };
                int idx = Array.IndexOf(spellNames, u.Name);
                return !_spellManager.IsSpellUnlocked(idx);
            }
            return true;
        }
        private string ParseText(string text, SpriteFont font, int width)
        {
            string line = string.Empty;
            string returnString = string.Empty;
            string[] wordArray = text.Split(' ');

            foreach (string word in wordArray)
            {
                if (font.MeasureString(line + word).X > width)
                {
                    returnString = returnString + line + "\n";
                    line = string.Empty;
                }

                line = line + word + " ";
            }

            return returnString + line;
        }


        public void DrawCard(SpriteBatch sb, Rectangle rect, UpgradeOption option, bool isHovered, SpriteFont font)
        {
            // 1. Background & Border
            Color bgColor = isHovered ? Color.DarkSlateBlue : Color.Black * 0.9f;
            Color borderColor = isHovered ? Color.Cyan : Color.Gray;

            sb.Draw(_pixel, rect, bgColor);

            int b = 2;
            sb.Draw(_pixel, new Rectangle(rect.X, rect.Y, rect.Width, b), borderColor);
            sb.Draw(_pixel, new Rectangle(rect.X, rect.Bottom - b, rect.Width, b), borderColor);
            sb.Draw(_pixel, new Rectangle(rect.X, rect.Y, b, rect.Height), borderColor);
            sb.Draw(_pixel, new Rectangle(rect.Right - b, rect.Y, b, rect.Height), borderColor);

            // 2. Icon (Fixed Position at top)
            int iconSize = 64;
            int iconY = rect.Y + 30;
            if (option.Icon != null)
            {
                Rectangle iconRect = new Rectangle(rect.Center.X - (iconSize / 2), iconY, iconSize, iconSize);
                sb.Draw(option.Icon, iconRect, Color.White);
            }

            if (font != null)
            {
                // 3. Title (Centered below icon)
                string title = option.Name;
                Vector2 titleSize = font.MeasureString(title);
                // Ensure title fits width, scale down if massive
                float titleScale = 1.0f;
                if (titleSize.X > rect.Width - 20) titleScale = (rect.Width - 20) / titleSize.X;

                Vector2 titlePos = new Vector2(
                    rect.Center.X - (titleSize.X * titleScale) / 2,
                    iconY + iconSize + 15
                );

                sb.DrawString(font, title, titlePos, Color.Gold, 0f, Vector2.Zero, titleScale, SpriteEffects.None, 0f);

                // 4. Description (Perfectly Centered in remaining space)
                // Calculate remaining vertical space
                float startY = titlePos.Y + (titleSize.Y * titleScale) + 10;
                float endY = rect.Bottom - 10;
                float availableHeight = endY - startY;

                // Wrap text
                string wrappedDesc = ParseText(option.Description, font, rect.Width - 30);
                Vector2 descSize = font.MeasureString(wrappedDesc);

                // Center vertically in the available space
                float descY = startY + (availableHeight / 2) - (descSize.Y / 2);

                // Center horizontally
                Vector2 descPos = new Vector2(rect.Center.X - descSize.X / 2, descY);

                sb.DrawString(font, wrappedDesc, descPos, Color.White);
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;

namespace Pale_Roots_1
{
    // WorldObject is a Sprite used for static and animated map objects (trees, rocks, ruins).
    // Responsibilities:
    // - Maintain collision footprint that tightly fits visible non-transparent pixels near the sprite's feet.
    // - Provide a CollisionBox used by other actors for obstacle detection.
    // - Render itself and optionally a debug collision box.
    // Interactions:
    // - CollisionBox is used by RotatingSprite.IsColliding and Player/Enemy movement logic to block movement.
    // - Uses Helper.GetSourceRect to map asset keys to sheet locations when created by LevelManager.
    public class WorldObject : Sprite
    {
        public bool IsSolid { get; set; }
        public string AssetName { get; set; }
        private static Texture2D _debugTexture;

        // Percentages used when defaulting to simpler bounding box calculations.
        public float BoxWidthPercentage { get; set; } = 0.5f;
        public float BoxHeightPercentage { get; set; } = 0.2f;

        private int _pixelOffsetX;
        private int _pixelWidth;

        // Construct a map object; frameCount allows animated variants.
        public WorldObject(Game g, Texture2D texture, Vector2 pos, int frameCount, bool isSolid)
            : base(g, texture, pos, frameCount, 1.0)
        {
            IsSolid = isSolid;
            mililsecondsBetweenFrames = 200; // slower default for environmental animations
            Scale = 3.0f; // chosen scale to match tile grid; adjustable by level creation code
        }

        // Collision box focuses on the feet area rather than the whole sprite to allow better depth/passability.
        public Rectangle CollisionBox
        {
            get
            {
                float scale = (float)Scale;

                int finalHeight = (int)(spriteHeight * scale * 0.2f);
                int finalWidth = (int)(_pixelWidth * scale);

                float leftEdge = position.X - (spriteWidth * scale / 2);
                int x = (int)(leftEdge + (_pixelOffsetX * scale));

                int y = (int)(position.Y + (spriteHeight * scale / 2) - finalHeight);

                return new Rectangle(x, y, finalWidth, finalHeight);
            }
        }

        // Analyze the sprite's bottom area to determine a tight pixel footprint for collision.
        // Stores pixel offsets so CollisionBox can be computed quickly later.
        private void CalculatePixelTightBox()
        {
            Color[] rawData = new Color[spriteImage.Width * spriteImage.Height];
            spriteImage.GetData(rawData);

            Rectangle src = sourceRectangle;

            int startY = src.Y + (int)(src.Height * 0.8f);
            int endY = src.Y + src.Height;

            int minX = src.Width;
            int maxX = 0;
            bool foundPixels = false;

            for (int y = startY; y < endY; y++)
            {
                for (int x = src.X; x < src.X + src.Width; x++)
                {
                    int index = y * spriteImage.Width + x;
                    if (rawData[index].A > 200)
                    {
                        int localX = x - src.X;
                        if (localX < minX) minX = localX;
                        if (localX > maxX) maxX = localX;
                        foundPixels = true;
                    }
                }
            }

            if (foundPixels)
            {
                _pixelOffsetX = minX;
                _pixelWidth = maxX - minX;
            }
            else
            {
                // fallback if bottom has no opaque pixels
                _pixelOffsetX = (int)(src.Width * 0.25f);
                _pixelWidth = (int)(src.Width * 0.5f);
            }
        }

        // Override to compute tight collision box whenever the source rectangle is set.
        public new void SetSpritesheetLocation(Rectangle source)
        {
            base.SetSpriteSheetLocation(source);
            CalculatePixelTightBox();
        }

        // Draw red rectangle lines for debug; creates a shared 1x1 texture as needed.
        public void DrawDebug(SpriteBatch spriteBatch)
        {
            if (_debugTexture == null)
            {
                _debugTexture = new Texture2D(game.GraphicsDevice, 1, 1);
                _debugTexture.SetData(new[] { Color.Red });
            }

            Rectangle box = CollisionBox;
            int thickness = 2;

            spriteBatch.Draw(_debugTexture, new Rectangle(box.X, box.Y, box.Width, thickness), Color.Red);
            spriteBatch.Draw(_debugTexture, new Rectangle(box.X, box.Bottom, box.Width, thickness), Color.Red);
            spriteBatch.Draw(_debugTexture, new Rectangle(box.X, box.Y, thickness, box.Height), Color.Red);
            spriteBatch.Draw(_debugTexture, new Rectangle(box.Right, box.Y, thickness, box.Height), Color.Red);
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // ChargingBattleEnemy: a fast, aggressive enemy.
    // Inherits movement, AI states and combat hooks from CircularChasingEnemy -> Enemy -> RotatingSprite.
    public class ChargingBattleEnemy : CircularChasingEnemy
    {
        // Tunable multiplier for how much faster this enemy moves while charging.
        // Other systems (spawn/level/balance) can change this at runtime.
        public float ChargeSpeedMultiplier { get; set; } = 1.5f;
        
        // Base movement speed used when not charging.
        private float _baseVelocity;

        // Constructor matches base signatures so factories/LevelManager can create this class like other enemies.
        public ChargingBattleEnemy(Game g, Texture2D texture, Vector2 position1, int framecount)
            : base(g, texture, position1, framecount)
        {
            // Choose default non-charging speed.
            _baseVelocity = 3.0f;

            // Set the inherited Velocity field so movement/animation systems use correct speed.
            Velocity = _baseVelocity;
            
            // Increase inherited chase detection radius so this enemy detects targets farther away.
            // Uses shared GameConstants (defined elsewhere).
            ChaseRadius = GameConstants.DefaultChaseRadius * 1.5f;
            
            // Start this instance in the Charging AI state; the base UpdateAI will treat it accordingly.
            CurrentAIState = AISTATE.Charging;
        }

        // Called by the base AI when in the Charging state.
        // 'obstacles' comes from LevelManager each frame and contains map objects (WorldObject) to avoid.
        protected override void PerformCharge(List<WorldObject> obstacles)
        {
            // Temporarily boost Velocity for charge movement/collision/animation.
            Velocity = _baseVelocity * ChargeSpeedMultiplier;
            
            // Immediate leftward nudge to create a lunge effect (project assumes left is the player side).
            position.X -= Velocity;

            // Build a distant left target and call the inherited MoveToward helper.
            // MoveToward (in a base class) performs obstacle-aware stepping and rotation.
            Vector2 target = new Vector2(position.X - 1000, position.Y);
            MoveToward(target, Velocity, obstacles);
        }

        // Called by the base AI when chasing a specific target.
        // Restores normal speed and defers to the base chase behavior that handles steering & state transitions.
        protected override void PerformChase(List<WorldObject> obstacles)
        {
            Velocity = _baseVelocity;
            base.PerformChase(obstacles); // base handles moving toward CurrentTarget and switching to InCombat.
        }

        // Called by the base AI when engaged in combat.
        // Use normal speed and let the base combat logic handle attacks/animations through CombatSystem.
        protected override void PerformCombat(GameTime gameTime)
        {
            Velocity = _baseVelocity;
            base.PerformCombat(gameTime);
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // `CircularChasingEnemy` chases targets inside a circular radius and returns to its start when the target leaves.
    // It builds on `Enemy` and uses `CombatSystem`, `MoveToward`, and AI state fields from the base class.
    public class CircularChasingEnemy : Enemy
    {
        // How far this enemy will detect and begin chasing a target.
        public float ChaseRadius { get; set; }
        
        // Tracks whether the enemy is currently pursuing a target.
        private bool _isAggro = false;

        // Constructor matches the base `Enemy` signatures so factories/LevelManager can instantiate this like other enemies.
        public CircularChasingEnemy(Game g, Texture2D texture, Vector2 position1, int framecount)
            : base(g, texture, position1, framecount)
        {
            // Default detection radius read from a shared configuration (`GameConstants`).
            ChaseRadius = GameConstants.DefaultChaseRadius;
            // Default movement speed for this enemy type (inherited `Velocity` used by movement/animation).
            Velocity = 2.0f;
        }

        // AI tick called by `Enemy.Update` with obstacle data from the level.
        // - Verifies the current target is still valid and inside an extended chase boundary.
        // - If target escaped, clear target bookkeeping and switch to wandering.
        protected override void UpdateAI(GameTime gameTime, List<WorldObject> obstacles)
        {
            // If we have a target, check how far away it is using the shared `CombatSystem`.
            if (CurrentTarget != null)
            {
                float distanceToTarget = CombatSystem.GetDistance(this, CurrentTarget);
                
                // If the target moved well outside the chase zone (buffered by 1.5x), disengage.
                // `CombatSystem.ClearTarget` updates central target lists; `CurrentAIState` controls behavior next tick.
                if (distanceToTarget > ChaseRadius * 1.5f)
                {
                    _isAggro = false;
                    CombatSystem.ClearTarget(this);
                    CurrentAIState = AISTATE.Wandering;
                }
            }
            
            // Let the base class perform its shared AI work (cooldowns, state dispatch to PerformX methods).
            base.UpdateAI(gameTime, obstacles);
        }

        // Wander behavior overridden so the enemy returns to its `startPosition` when not aggressive.
        protected override void PerformWander(List<WorldObject> obstacles)
        {
            // If we're not close to the start, path back slowly using the inherited `MoveToward` helper.
            if (Vector2.Distance(position, startPosition) > 5f)
            {
                MoveToward(startPosition, Velocity * 0.5f, obstacles);
            }
            // Otherwise remain idle at `startPosition`.
        }

        // Utility to ask whether a potential `ICombatant` is within the configured chase radius.
        public bool IsInChaseZone(ICombatant target)
        {
            if (target == null) return false;
            return CombatSystem.GetDistance(this, target) <= ChaseRadius;
        }

        // External trigger to make this enemy start chasing a valid target.
        // - Validity is checked with `CombatSystem.IsValidTarget`.
        // - Assigns the target centrally and flips AI state to `Chasing`.
        public void Aggro(ICombatant target)
        {
            if (target == null || !CombatSystem.IsValidTarget(this, target)) return;
            
            _isAggro = true;
            CombatSystem.AssignTarget(this, target);
            CurrentAIState = AISTATE.Chasing;
        }
    }
}
using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    // Enemy: an AI-controlled actor that can move, pick targets, fight and die.
    // - Uses CombatSystem for targeting/damage and AnimationManager for visuals.
    // - Inherits movement/rotation helpers from RotatingSprite and exposes ICombatant surface.
    public class Enemy : RotatingSprite, ICombatant
    {
        // Lifecycle and AI states used by the AI loop below.
        public enum ENEMYSTATE { ALIVE, DYING, DEAD }
        public enum AISTATE { Charging, Chasing, InCombat, Wandering, Hurt }

        public bool IsStunned { get; set; }

        // Animation, facing and visual state
        private AnimationManager _animManager;
        private int _currentDirectionIndex = 2;
        private SpriteEffects _flipEffect = SpriteEffects.None;

        // Physics / impact
        private Vector2 _knockBackVelocity;

        // Shared health bar texture (created once)
        private static Texture2D _healthBarTexture;
        private bool _drawHealthBar = true;

        // Movement bookkeeping
        private Vector2 _previousPosition;

        // Lifecycle backing field
        private ENEMYSTATE _lifecycleState = ENEMYSTATE.ALIVE;
        public ENEMYSTATE LifecycleState
        {
            get => _lifecycleState;
            set => _lifecycleState = value;
        }

        // ICombatant surface (fields expected by CombatSystem and chase code)
        public string Name { get; set; } = "Enemy";
        public CombatTeam Team => CombatTeam.Enemy;
        public int MaxHealth { get; protected set; }
        public int AttackDamage { get; set; }
        public bool IsAlive => Health > 0 && _lifecycleState == ENEMYSTATE.ALIVE;
        public bool IsActive => Visible && _lifecycleState != ENEMYSTATE.DEAD;

        // Current target, synchronized to a Sprite reference for visuals
        private ICombatant _currentTarget;
        public ICombatant CurrentTarget
        {
            get => _currentTarget;
            set
            {
                _currentTarget = value;
                CurrentCombatPartner = value as Sprite;
            }
        }

        // Position / movement fields used by RotatingSprite and AI
        public Vector2 Position => position;
        protected float Velocity;
        protected Vector2 startPosition;
        protected Vector2 wanderTarget;
        private float _attackCooldown = 0f;
        private int _deathCountdown;

        // Modern constructor: takes a texture map for direction/animation sheets.
        public Enemy(Game g, Dictionary<string, Texture2D> textures, Vector2 userPosition, int framecount)
            : base(g, textures["Idle"], userPosition, framecount)
        {
            SetupCommonStats(userPosition);

            Scale = 3.0;
            _animManager = new AnimationManager();

            // Register directional animations (keys used elsewhere when switching animations)
            _animManager.AddAnimation("Idle", new Animation(textures["Idle"], 4, 0, 150f, true, 4, 0, true));
            _animManager.AddAnimation("Walk", new Animation(textures["Walk"], 8, 0, 150f, true, 4, 0, true));
            _animManager.AddAnimation("Attack", new Animation(textures["Attack"], 8, 0, 125f, false, 4, 0, true));
            _animManager.AddAnimation("Hurt", new Animation(textures["Hurt"], 6, 0, 150f, false, 4, 0, true));
            _animManager.AddAnimation("Death", new Animation(textures["Death"], 8, 0, 150f, false, 4, 0, true));

            _animManager.Play("Idle");
            SetupHealthBar(g);
        }

        // Legacy constructor for single-sheet enemies.
        public Enemy(Game g, Texture2D texture, Vector2 userPosition, int framecount)
            : base(g, texture, userPosition, framecount)
        {
            SetupCommonStats(userPosition);
            Scale = 3.0;
            _animManager = new AnimationManager();
            var legacyAnim = new Animation(texture, framecount, 0, 200f, true, 1, 0, false);

            // Use the same legacy animation for all states to remain compatible.
            _animManager.AddAnimation("Idle", legacyAnim);
            _animManager.AddAnimation("Walk", legacyAnim);
            _animManager.AddAnimation("Attack", legacyAnim);
            _animManager.AddAnimation("Hurt", legacyAnim);
            _animManager.AddAnimation("Death", legacyAnim);

            _animManager.Play("Idle");
            SetupHealthBar(g);
        }

        // Shared initialization used by both constructors.
        private void SetupCommonStats(Vector2 pos)
        {
            startPosition = pos;
            _previousPosition = pos;
            Velocity = GameConstants.DefaultEnemySpeed;
            MaxHealth = GameConstants.DefaultHealth;
            Health = MaxHealth;
            AttackDamage = GameConstants.DefaultMeleeDamage;
            _deathCountdown = GameConstants.DeathCountdown;
            CurrentAIState = AISTATE.Charging;
        }

        // Create a 1x1 white texture once for health bars used in Draw.
        private void SetupHealthBar(Game g)
        {
            if (_healthBarTexture == null)
            {
                _healthBarTexture = new Texture2D(g.GraphicsDevice, 1, 1);
                _healthBarTexture.SetData(new[] { Color.White });
            }
        }

        // Top-level Update: apply knockback, run rotation/movement update, pick animations and handle dying.
        public virtual void Update(GameTime gametime)
        {
            // Apply residual knockback and damp it over time.
            if (_knockBackVelocity != Vector2.Zero)
            {
                position += _knockBackVelocity;
                _knockBackVelocity *= GameConstants.KnockbackFriction;
                if (_knockBackVelocity.Length() < 0.1f) _knockBackVelocity = Vector2.Zero;
            }

            base.Update(gametime);   // RotatingSprite/Sprite update (timing, source rect)
            UpdateDirection();       // Choose facing row for animations

            // Select animation key based on lifecycle and AI state.
            string animKey = "Idle";

            if (_lifecycleState == ENEMYSTATE.DYING)
            {
                animKey = "Death";
            }
            else if (CurrentAIState == AISTATE.Hurt)
            {
                animKey = "Hurt";
            }
            else if (CurrentAIState == AISTATE.InCombat && _attackCooldown > 200)
            {
                animKey = "Attack";
            }
            else if (Velocity > 0.1f || CurrentAIState == AISTATE.Chasing || CurrentAIState == AISTATE.Charging)
            {
                animKey = "Walk";
            }

            _animManager.Play(animKey);
            _animManager.Update(gametime);

            if (_lifecycleState == ENEMYSTATE.DYING) UpdateDying(gametime);

            _previousPosition = position;
        }

        // Update that includes obstacle-aware AI behavior from the level.
        public void Update(GameTime gametime, List<WorldObject> obstacles)
        {
            this.Update(gametime);
            if (_lifecycleState == ENEMYSTATE.ALIVE)
            {
                UpdateAI(gametime, obstacles);
            }
        }

        // Core AI tick: handles stun, cooldowns, target validation and dispatch to state methods.
        protected virtual void UpdateAI(GameTime gameTime, List<WorldObject> obstacles)
        {
            if (IsStunned) return;

            if (_attackCooldown > 0)
                _attackCooldown -= (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            // If current target is invalid, clear it and wander.
            if (_currentTarget != null && !CombatSystem.IsValidTarget(this, _currentTarget))
            {
                CombatSystem.ClearTarget(this);
                CurrentAIState = AISTATE.Wandering;
            }

            // Hurt state will transition back to chasing after cooldown.
            if (CurrentAIState == AISTATE.Hurt)
            {
                if (_attackCooldown <= 0)
                {
                    CurrentAIState = AISTATE.Chasing;
                }
            }

            // Dispatch to specific AI behavior methods defined below (overridable by children).
            switch (CurrentAIState)
            {
                case AISTATE.Charging: PerformCharge(obstacles); break;
                case AISTATE.Chasing: PerformChase(obstacles); break;
                case AISTATE.InCombat: PerformCombat(gameTime); break;
                case AISTATE.Wandering: PerformWander(obstacles); break;
            }
        }

        // Default charge: nudge left and path toward a distant point (children may override).
        protected virtual void PerformCharge(List<WorldObject> obstacles)
        {
            position.X -= Velocity;
            Vector2 target = new Vector2(position.X - 1000, position.Y);
            MoveToward(target, Velocity, obstacles);
        }

        // Apply an external knockback impulse (stackable).
        public void ApplyKnockback(Vector2 force)
        {
            _knockBackVelocity += force;
        }

        // Chase current target; switch to InCombat when within engage range.
        protected virtual void PerformChase(List<WorldObject> obstacle)
        {
            if (_currentTarget == null) { CurrentAIState = AISTATE.Wandering; return; }
            MoveToward(_currentTarget.Center, Velocity, obstacle);
            if (CombatSystem.GetDistance(this, _currentTarget) < GameConstants.CombatEngageRange)
            {
                CurrentAIState = AISTATE.InCombat;
            }
        }

        // Combat loop: face target, attack if in melee range and off cooldown, break if target flees.
        protected virtual void PerformCombat(GameTime gameTime)
        {
            if (_currentTarget == null || !_currentTarget.IsAlive) { CurrentAIState = AISTATE.Wandering; return; }
            SnapToFace(_currentTarget.Center);
            if (CombatSystem.GetDistance(this, _currentTarget) < GameConstants.MeleeAttackRange && _attackCooldown <= 0)
            {
                PerformAttack();
            }
            if (CombatSystem.GetDistance(this, _currentTarget) > GameConstants.CombatBreakRange)
            {
                CurrentAIState = AISTATE.Chasing;
            }
        }

        // Wandering: pick a random nearby point and walk there slowly.
        protected virtual void PerformWander(List<WorldObject> obstacles)
        {
            if (wanderTarget == Vector2.Zero || Vector2.Distance(position, wanderTarget) < 5f)
            {
                wanderTarget = startPosition + new Vector2(
                    CombatSystem.RandomInt(-GameConstants.WanderRadius, GameConstants.WanderRadius + 1),
                    CombatSystem.RandomInt(-GameConstants.WanderRadius, GameConstants.WanderRadius + 1)
                );
            }
            MoveToward(wanderTarget, Velocity * 0.5f, obstacles);
        }

        // Handle dying countdown then hide and mark dead.
        protected virtual void UpdateDying(GameTime gameTime)
        {
            _deathCountdown--;
            if (_deathCountdown <= 0)
            {
                _lifecycleState = ENEMYSTATE.DEAD;
                Visible = false;
            }
        }

        // Take damage, set Hurt or Dying state and notify animation system.
        public virtual void TakeDamage(int amount, ICombatant attacker)
        {
            if (!IsAlive) return;

            Health -= amount;

            if (Health <= 0)
            {
                Die();
            }
            else
            {
                CurrentAIState = AISTATE.Hurt;
                _attackCooldown = 500f; // brief stun before action
                _animManager.Play("Hurt");
            }
        }

        // Trigger attack animation and use CombatSystem to apply damage.
        public virtual void PerformAttack()
        {
            if (_currentTarget == null || _attackCooldown > 0) return;
            _animManager.Play("Attack");
            CombatSystem.DealDamage(this, _currentTarget, AttackDamage);
            _attackCooldown = GameConstants.DefaultAttackCooldown;
        }

        // Enter dying lifecycle and clear target bookkeeping.
        public virtual void Die()
        {
            _lifecycleState = ENEMYSTATE.DYING;
            _deathCountdown = 80;
            CombatSystem.ClearTarget(this);
        }

        // Choose animation row based on target position or recent movement.
        private void UpdateDirection()
        {
            // If we have a target, face them.
            if (CurrentTarget != null)
            {
                Vector2 diff = CurrentTarget.Position - this.Position;
                if (Math.Abs(diff.X) > Math.Abs(diff.Y))
                    _currentDirectionIndex = (diff.X > 0) ? 3 : 2; // Right vs Left
                else
                    _currentDirectionIndex = (diff.Y > 0) ? 0 : 1; // Down vs Up
            }
            else
            {
                Vector2 movement = position - _previousPosition;

                // Only update facing if we actually moved.
                if (movement.Length() > 0.5f)
                {
                    if (Math.Abs(movement.X) > Math.Abs(movement.Y))
                        _currentDirectionIndex = (movement.X > 0) ? 3 : 2;
                    else
                        _currentDirectionIndex = (movement.Y > 0) ? 0 : 1;
                }
            }
        }

        // Draw current animation and optional health bar above the sprite.
        public override void Draw(SpriteBatch spriteBatch)
        {
            if (Visible)
            {
                _animManager.Draw(spriteBatch, position, (float)Scale, _flipEffect, _currentDirectionIndex);
            }

            if (_drawHealthBar && IsAlive)
            {
                DrawHealthBar(spriteBatch);
            }
        }

        // Simple health bar rendered using a shared 1x1 texture.
        protected virtual void DrawHealthBar(SpriteBatch spriteBatch)
        {
            int barWidth = spriteWidth;
            int barHeight = 5;
            int barX = (int)position.X - (barWidth / 2);
            int barY = (int)position.Y - spriteHeight / 2 - 10;

            spriteBatch.Draw(_healthBarTexture, new Rectangle(barX, barY, barWidth, barHeight), Color.Red);

            float healthPercent = (float)Health / MaxHealth;
            int currentBarWidth = (int)(barWidth * healthPercent);

            Color healthColor = healthPercent > 0.6f ? Color.Green : healthPercent > 0.3f ? Color.Orange : Color.Red;

            spriteBatch.Draw(_healthBarTexture, new Rectangle(barX, barY, currentBarWidth, barHeight), healthColor);
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    // Stationary turret that aims at the player and fires a reusable projectile.
    // Inherits visuals/movement helpers from Enemy -> RotatingSprite -> Sprite.
    internal class Enemy_sentry : Enemy
    {
        // Projectile instance this sentry controls. Assigned by level factory or engine.
        // Reusing one Projectile avoids per-shot allocations; Projectile tracks its own state.
        public Projectile MyProjectile { get; set; }

        // Detection and firing timers
        private float detectionRadius = 400f;
        private float reloadTimer = 0;
        private float timeToReload = 2000f; // milliseconds between shots

        // NOTE: These fields shadow the `MaxHealth`/`Health` members on the base `Enemy`.
        // Keep that in mind  it's fine for simple local bars but can be confusing.
        public float MaxHealth = 100;
        public float CurrentHealth = 100;

        // Shared 1x1 texture used to draw the health bar background/foreground.
        private static Texture2D healthTexture;

        public Enemy_sentry(Game g, Texture2D tx, Vector2 StartPosition, int NoOfFrames)
            : base(g, tx, StartPosition, NoOfFrames)
        {
            // How fast the turret rotates when tracking a target (inherited field on RotatingSprite).
            this.rotationSpeed = 0.15f;

            // Create the 1x1 white texture once and reuse it for all sentries.
            if (healthTexture == null)
            {
                healthTexture = new Texture2D(g.GraphicsDevice, 1, 1);
                healthTexture.SetData(new[] { Color.White });
            }
        }

        // Attach a Projectile instance so the sentry can control firing and updates.
        // Typical caller: LevelManager, ChaseAndFireEngine, or a spawn factory.
        public void LoadProjectile(Projectile p)
        {
            MyProjectile = p;
        }

        // Main update called from the level (use this instead of Enemy.Update when you need player info).
        // - Decrements reload timer
        // - If player is in range, rotate to face them and attempt to fire
        // - Keeps the projectile positioned at the turret when it's "still"
        public void UpdateSentry(GameTime gameTime, Player p)
        {
            // Count down reload timer in milliseconds
            if (reloadTimer > 0)
                reloadTimer -= (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            // Use Sprite/RotatingSprite center to compute distance to player
            // Player exposes `CentrePos` (note British spelling in Player).
            float distance = Vector2.Distance(this.Center, p.CentrePos);

            if (distance < detectionRadius)
            {
                // `follow` is inherited from RotatingSprite/Enemy and orients the turret toward the player.
                this.follow(p);

                // Fire only if a projectile is loaded, it's idle, and the turret has reloaded.
                if (MyProjectile != null &&
                    MyProjectile.ProjectileState == Projectile.PROJECTILE_STATE.STILL &&
                    reloadTimer <= 0)
                {
                    // Ask the projectile to fire toward the player's current position.
                    MyProjectile.fire(p.CentrePos);
                    reloadTimer = timeToReload;
                }
            }

            // If the projectile is idle, keep it visually attached to the turret; always update it.
            if (MyProjectile != null)
            {
                if (MyProjectile.ProjectileState == Projectile.PROJECTILE_STATE.STILL)
                {
                    MyProjectile.position = this.position;
                }
                MyProjectile.Update(gameTime);
            }

            // Call base update to run animations and other shared logic in Enemy.
            base.Update(gameTime);
        }

        // Draw turret, its projectile, and a compact health bar.
        public override void Draw(SpriteBatch spriteBatch)
        {
            base.Draw(spriteBatch);

            if (MyProjectile != null)
            {
                MyProjectile.Draw(spriteBatch);
            }

            // Health bar above the turret (uses spriteWidth/spriteHeight from Sprite base).
            int barWidth = spriteWidth;
            int barHeight = 5;
            int barX = (int)position.X - (barWidth / 2);
            int barY = (int)position.Y - 10;

            // Background = missing health (red)
            spriteBatch.Draw(healthTexture, new Rectangle(barX, barY, barWidth, barHeight), Color.Red);

            // Foreground = current health (green)
            if (CurrentHealth < 0) CurrentHealth = 0;
            int currentBarWidth = (int)(barWidth * (CurrentHealth / MaxHealth));
            spriteBatch.Draw(healthTexture, new Rectangle(barX, barY, currentBarWidth, barHeight), Color.Green);
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // Patrol enemy that walks between two points.
    // Inherits AI, movement and rendering from Enemy -> RotatingSprite -> Sprite.
    public class PlatformEnemy : Enemy
    {
        // Patrol endpoints and the active target we're moving toward.
        private Vector2 _pointA;
        private Vector2 _pointB;
        private Vector2 _currentPatrolTarget;
        
        // How quickly position interpolates toward the patrol target (0-1).
        public float PatrolLerpSpeed { get; set; } = 0.05f;

        // Constructor receives two positions and uses the base Enemy constructor for setup.
        // Level/Factory code constructs this the same way as other enemies.
        public PlatformEnemy(Game g, Texture2D texture, Vector2 position1, Vector2 position2, int framecount)
            : base(g, texture, position1, framecount)
        {
            _pointA = position1;
            _pointB = position2;
            _currentPatrolTarget = _pointB;
            
            // Start in the wandering AI state so UpdateAI will call PerformWander.
            CurrentAIState = AISTATE.Wandering;
        }

        // Patrol logic runs while wandering.
        // - Uses Vector2.Lerp to smoothly move between points.
        // - Swaps target when close enough to an endpoint.
        // - Ignores obstacles here (no MoveToward); if you need obstacle avoidance, switch to MoveToward.
        protected override void PerformWander(List<WorldObject> obstacles)
        {
            // Smoothly move toward the current patrol target.
            position = Vector2.Lerp(position, _currentPatrolTarget, PatrolLerpSpeed);
            
            // When we reach one endpoint, set the other as the next target.
            if (Vector2.Distance(position, _pointB) < 1)
            {
                _currentPatrolTarget = _pointA;
            }
            else if (Vector2.Distance(position, _pointA) < 1)
            {
                _currentPatrolTarget = _pointB;
            }
        }

        // Use the same patrol behavior while in Charging state so the enemy doesn't lunge.
        protected override void PerformCharge(List<WorldObject> obstacles)
        {
            PerformWander(obstacles);
        }
        
        // After combat finishes, return to patrol.
        // Calls base combat behavior first (handles facing/attacks), then ensures we resume wandering if target is gone.
        protected override void PerformCombat(GameTime gameTime)
        {
            base.PerformCombat(gameTime);
            
            // If we lost our target, go back to patrolling.
            if (CurrentTarget == null || !CurrentTarget.IsAlive)
            {
                CurrentAIState = AISTATE.Wandering;
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // RandomEnemy: picks screen-wide random targets and wanders between them.
    // - Uses the shared RNG via CombatSystem.RandomInt (avoids creating new Random instances).
    // - Uses MoveToward from RotatingSprite/Enemy so it respects obstacles passed from level code.
    public class RandomEnemy : Enemy
    {
        // Current random target position on screen
        private Vector2 _randomTarget;

        // Constructor uses the base Enemy constructor for setup and starts in Wandering state.
        public RandomEnemy(Game g, Texture2D texture, Vector2 userPosition, int framecount)
            : base(g, texture, userPosition, framecount)
        {
            _randomTarget = CreateRandomTarget();
            
            // This enemy wanders rather than charging at spawn.
            CurrentAIState = AISTATE.Wandering;
        }

        // Pick a random point inside the viewport (uses CombatSystem's helper RNG).
        private Vector2 CreateRandomTarget()
        {
            int rx = CombatSystem.RandomInt(0, game.GraphicsDevice.Viewport.Width - spriteWidth);
            int ry = CombatSystem.RandomInt(0, game.GraphicsDevice.Viewport.Height - spriteHeight);
            return new Vector2(rx, ry);
        }

        // Wander behavior: walk toward the random target and choose a new one on arrival.
        protected override void PerformWander(List<WorldObject> obstacles)
        {
            // MoveToward handles collision checking with obstacles.
            MoveToward(_randomTarget, Velocity, obstacles);

            // When close enough, pick a new random target inside the viewport.
            if (Vector2.Distance(position, _randomTarget) < 5f)
            {
                int rx = CombatSystem.RandomInt(0, game.GraphicsDevice.Viewport.Width - spriteWidth);
                int ry = CombatSystem.RandomInt(0, game.GraphicsDevice.Viewport.Height - spriteHeight);
                _randomTarget = new Vector2(rx, ry);
            }
        }

        // This enemy doesn't charge; use the wander behavior instead.
        protected override void PerformCharge(List<WorldObject> obstacles)
        {
            PerformWander(obstacles);
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // SentryEnemy: stationary turret that rotates to track a target and fires a single reusable Projectile.
    // - Inherits AI/animation/visibility from Enemy -> RotatingSprite.
    // - Uses CombatSystem for target validation/distance checks.
    public class SentryEnemy : Enemy
    {
        // Projectile this sentry controls (assigned by level/factory). Projectile manages its own state.
        public Projectile MyProjectile { get; set; }
        
        // Timing and detection
        private float _reloadTimer = 0;            // current cooldown
        private float _reloadTime;                 // cooldown duration (ms)
        private float _detectionRadius;            // how far the sentry can detect targets

        // Constructor: configure rotation speed, reload and detection from shared constants.
        public SentryEnemy(Game g, Texture2D tx, Vector2 startPosition, int noOfFrames)
            : base(g, tx, startPosition, noOfFrames)
        {
            rotationSpeed = 0.15f;                             // how fast the turret rotates to face targets
            _reloadTime = GameConstants.DefaultReloadTime;     // configurable shared value
            _detectionRadius = GameConstants.DefaultDetectionRadius;
            
            // Sentry stays in place; use Wandering so base AI won't try to move it.
            CurrentAIState = AISTATE.Wandering;
        }

        // Attach a Projectile instance so the sentry can fire and update it.
        public void LoadProjectile(Projectile p)
        {
            MyProjectile = p;
        }

        // AI update override: handle reload, detection, orientation and projectile updates.
        protected override void UpdateAI(GameTime gameTime, List<WorldObject> obstacles)
        {
            // Countdown reload timer (milliseconds)
            if (_reloadTimer > 0)
                _reloadTimer -= (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            // Only act if we have a valid target assigned by external systems (CombatSystem/LevelManager)
            if (CurrentTarget != null && CombatSystem.IsValidTarget(this, CurrentTarget))
            {
                float distance = CombatSystem.GetDistance(this, CurrentTarget);

                // If target is within detection range, rotate to face them and try to fire
                if (distance < _detectionRadius)
                {
                    Follow(CurrentTarget.Center); // inherited rotation helper

                    if (MyProjectile != null &&
                        MyProjectile.ProjectileState == Projectile.PROJECTILE_STATE.STILL &&
                        _reloadTimer <= 0)
                    {
                        FireAtTarget();
                    }
                }
            }

            // Keep projectile visually attached while idle and always update it.
            if (MyProjectile != null)
            {
                if (MyProjectile.ProjectileState == Projectile.PROJECTILE_STATE.STILL)
                {
                    MyProjectile.position = this.position;
                }
                MyProjectile.Update(gameTime);
            }

            // Intentionally do not call base.UpdateAI: sentry does not use movement/chase/wander state logic.
        }

        // Centralized fire logic so the timing reset and firing call are in one place.
        private void FireAtTarget()
        {
            if (CurrentTarget == null || MyProjectile == null) return;

            MyProjectile.fire(CurrentTarget.Center);
            _reloadTimer = _reloadTime;
        }

        // Disable movement behaviors: sentries are stationary.
        protected override void PerformCharge(List<WorldObject> obstacles) { }

        protected override void PerformChase(List<WorldObject> obstacles)
        {
            // When "chasing" (if base sets it), just rotate to face the current target.
            if (CurrentTarget != null)
            {
                Follow(CurrentTarget.Center);
            }
        }

        protected override void PerformWander(List<WorldObject> obstacles) { }

        // Sentry uses projectiles instead of melee; Attack is handled in UpdateAI via FireAtTarget.
        public override void PerformAttack() { }

        // Draw sentry and its projectile (projectile draws itself).
        public override void Draw(SpriteBatch spriteBatch)
        {
            base.Draw(spriteBatch);

            if (MyProjectile != null)
            {
                MyProjectile.Draw(spriteBatch);
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    // Simple camera that centers on a point, clamps to map bounds and produces a transform matrix
    // Consumers (LevelManager / Game1 / drawing code) should use CurrentCameraTranslation as the SpriteBatch transform.
    public class Camera
    {
        // World-space position the camera is centered on (in world coordinates).
        public Vector2 Position { get; private set; }

        // Zoom factor (1.0 = 100%). Affects how much of the map is visible.
        public float Zoom { get; set; } = 1.0f;

        // Matrix to pass into SpriteBatch.Begin(transformMatrix: CurrentCameraTranslation)
        // Updated whenever Position or Zoom changes via LookAt/follow.
        public Matrix CurrentCameraTranslation { get; private set; }

        // Map size in world units; used to clamp camera so we don't show outside the level.
        private Vector2 _mapSize;

        // startPos: initial camera center. mapSize: full world extents (width, height).
        public Camera(Vector2 startPos, Vector2 mapSize)
        {
            Position = startPos;
            _mapSize = mapSize;
            Zoom = 1.0f;
        }

        // Move camera immediately to targetPos and update the transform.
        // viewport is required so we can compute how much world the screen shows at current Zoom.
        public void LookAt(Vector2 targetPos, Viewport viewport)
        {
            Position = targetPos;

            // Keep camera inside the map edges based on current viewport and Zoom.
            ClampPosition(viewport);

            // Build the matrix used for rendering transforms right away.
            UpdateMatrix(viewport);
        }

        // Smooth-follow or immediate follow API (same here as LookAt).
        // Call each frame with the player's world position and Viewport before drawing.
        public void follow(Vector2 targetPos, Viewport viewport)
        {
            Position = targetPos;
            ClampPosition(viewport);
            UpdateMatrix(viewport);
        }

        // Ensure the camera center stays inside the level bounds.
        // Uses visible world size = viewport / Zoom so clamping adjusts when Zoom changes.
        private void ClampPosition(Viewport viewport)
        {
            float visibleWidth = viewport.Width / Zoom;
            float visibleHeight = viewport.Height / Zoom;

            float halfWidth = visibleWidth / 2f;
            float halfHeight = visibleHeight / 2f;

            float newX = Position.X;
            float newY = Position.Y;

            // If the visible area is larger than the map, center on the map instead of clamping edges.
            if (visibleWidth > _mapSize.X)
            {
                newX = _mapSize.X / 2f;
            }
            else
            {
                newX = MathHelper.Clamp(Position.X, halfWidth, _mapSize.X - halfWidth);
            }

            if (visibleHeight > _mapSize.Y)
            {
                newY = _mapSize.Y / 2f;
            }
            else
            {
                newY = MathHelper.Clamp(Position.Y, halfHeight, _mapSize.Y - halfHeight);
            }

            Position = new Vector2(newX, newY);
        }

        // Recompute the transform matrix used for rendering:
        // 1) translate world so the camera center is at origin,
        // 2) scale (zoom), then
        // 3) translate so origin maps to the screen center.
        private void UpdateMatrix(Viewport viewport)
        {
            Vector2 screenCenter = new Vector2(viewport.Width / 2f, viewport.Height / 2f);

            CurrentCameraTranslation =
                Matrix.CreateTranslation(new Vector3(-Position.X, -Position.Y, 0)) *
                Matrix.CreateScale(new Vector3(Zoom, Zoom, 1)) *
                Matrix.CreateTranslation(new Vector3(screenCenter.X, screenCenter.Y, 0));
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Pale_Roots_1
{
    // Engine that runs the battle mode: owns level, camera, player/allies/enemies and coordinates update/draw/targeting.
    public class ChaseAndFireEngine
    {
        // Simple runtime tuning flags
        public bool SpawningBlocked { get; set; } = false;
        public float GlobalPlayerDamageMult { get; set; } = 1.0f;
        public float GlobalEnemyHealthMult { get; set; } = 1.0f;

        // Major subsystems (public so Game1 can access camera matrix before drawing)
        public LevelManager _levelManager;
        public Camera _camera;
        public Game _gameOwnedBy;

        // Runtime entity lists
        private Player _player;
        public List<Ally> _allies = new List<Ally>();
        public List<Enemy> _enemies = new List<Enemy>();

        private SpellManager _spellManager;

        // Battle state + spawn/origin positions
        private bool _battleStarted = false;
        private Vector2 _mapSize;
        private Vector2 _playerSpawnPos = new Vector2(500, 1230);
        private Vector2 _allySpawnOrigin = new Vector2(400, 1100);
        private Vector2 _enemySpawnOrigin = new Vector2(3200, 1230);

        // Shared texture dictionaries for enemy/ally types
        private List<Dictionary<string, Texture2D>> _allOrcTypes = new List<Dictionary<string, Texture2D>>();
        private Dictionary<string, Texture2D> _allyTextures = new Dictionary<string, Texture2D>();

        // Target-scan timer (we do perception checks at intervals)
        private float _targetingTimer = 0f;

        // Lightweight counters for UI
        public int EnemiesKilled { get; private set; }
        public int AlliesLost { get; private set; }

        // Constructor: create level, player, camera, load spells and armies.
        public ChaseAndFireEngine(Game game)
        {
            _gameOwnedBy = game;
            _mapSize = GameConstants.DefaultMapSize;

            _levelManager = new LevelManager(game);
            _levelManager.LoadLevel(0);

            // Create player (textures are loaded from Content by Game1 and passed here)
            _player = new Player(
                game,
                game.Content.Load<Texture2D>("wizard_strip3"),
                _playerSpawnPos,
                3
            );
            _player.Name = "Hero";

            // Camera: center on map and set sane zoom to fit viewport
            _camera = new Camera(Vector2.Zero, _mapSize);
            Viewport vp = game.GraphicsDevice.Viewport;
            float scaleX = (float)vp.Width / _mapSize.X;
            float scaleY = (float)vp.Height / _mapSize.Y;
            _camera.Zoom = Math.Min(scaleX, scaleY);
            _camera.LookAt(new Vector2(_mapSize.X / 2, _mapSize.Y / 2), vp);

            // Load spell effect atlases and create the SpellManager
            Texture2D txSmite = game.Content.Load<Texture2D>("Effects/Smite_spritesheet");
            Texture2D txNova = game.Content.Load<Texture2D>("Effects/HolyNova_spritesheet");
            Texture2D txFury = game.Content.Load<Texture2D>("Effects/HeavensFury_spritesheet");
            Texture2D txShield = game.Content.Load<Texture2D>("Effects/HolyShield_spritesheet");
            Texture2D txElectric = game.Content.Load<Texture2D>("Effects/Sprite-sheet"); // placeholder name
            Texture2D txJustice = game.Content.Load<Texture2D>("Effects/SwordOfJustice_spritesheet");

            _spellManager = new SpellManager(this, txSmite, txNova, txFury, txShield, txElectric, txJustice);

            // Prepare armies and wire event handlers
            InitializeArmies();
            SetupCombatEvents();
        }

        // Load enemy/ally texture sets and create initial units
        private void InitializeArmies()
        {
            for (int i = 1; i <= 3; i++)
            {
                var newOrcDict = new Dictionary<string, Texture2D>();

                newOrcDict["Idle"] = _gameOwnedBy.Content.Load<Texture2D>($"RealEnemyFolder/orc{i}_idle_full");
                newOrcDict["Walk"] = _gameOwnedBy.Content.Load<Texture2D>($"RealEnemyFolder/orc{i}_run_full");
                newOrcDict["Attack"] = _gameOwnedBy.Content.Load<Texture2D>($"RealEnemyFolder/orc{i}_attack_full");
                newOrcDict["Hurt"] = _gameOwnedBy.Content.Load<Texture2D>($"RealEnemyFolder/orc{i}_hurt_full");
                newOrcDict["Death"] = _gameOwnedBy.Content.Load<Texture2D>($"RealEnemyFolder/orc{i}_death_full");

                _allOrcTypes.Add(newOrcDict);
            }

            // Ally shared atlas
            _allyTextures["Walk"] = _gameOwnedBy.Content.Load<Texture2D>("Ally/Character_Walk");
            _allyTextures["Attack"] = _gameOwnedBy.Content.Load<Texture2D>("Ally/Character_Slash");
            _allyTextures["Idle"] = _gameOwnedBy.Content.Load<Texture2D>("Ally/Character_Idle");

            // Spawn a column of allies
            for (int i = 0; i < 5; i++)
            {
                Vector2 pos = _allySpawnOrigin + new Vector2(0, i * 100);
                var ally = new Ally(_gameOwnedBy, _allyTextures, pos, 4);
                ally.Name = $"Soldier {i + 1}";
                _allies.Add(ally);
            }

            // Spawn initial enemy formation
            CreateEnemyFormation(10);
        }

        // Arrange enemies in a simple triangular formation and apply type stats.
        private void CreateEnemyFormation(int count)
        {
            int currentRow = 0;
            int enemiesInCurrentRow = 1;
            int currentSlotInRow = 0;
            float spacingX = 80f;
            float spacingY = 80f;

            for (int i = 0; i < count; i++)
            {
                float xPos = _enemySpawnOrigin.X + (currentRow * spacingX);
                float rowHeight = (enemiesInCurrentRow - 1) * spacingY;
                float yPos = (_enemySpawnOrigin.Y - (rowHeight / 2f)) + (currentSlotInRow * spacingY);

                int typeIndex = 0;

                // Leader is tougher, others randomized
                if (i == 0)
                {
                    typeIndex = 2;
                }
                else
                {
                    typeIndex = CombatSystem.RandomInt(0, 2);
                }

                var enemy = new Enemy(_gameOwnedBy, _allOrcTypes[typeIndex], new Vector2(xPos, yPos), 4);

                if (typeIndex == 0)
                {
                    enemy.Name = $"Orc Grunt {i}";
                    enemy.AttackDamage = 10;
                }
                else if (typeIndex == 1)
                {
                    enemy.Name = $"Orc Warrior {i}";
                    enemy.AttackDamage = 20;
                }
                else
                {
                    enemy.Name = $"Orc Captain {i}";
                    enemy.AttackDamage = 35;
                    enemy.Scale = 3.5f;
                }

                _enemies.Add(enemy);

                currentSlotInRow++;
                if (currentSlotInRow >= enemiesInCurrentRow)
                {
                    currentRow++;
                    enemiesInCurrentRow++;
                    currentSlotInRow = 0;
                }
            }
        }

        // Subscribe to CombatSystem events to react to kills and damage.
        private void SetupCombatEvents()
        {
            CombatSystem.OnCombatantKilled += (killer, victim) =>
            {
                if (victim.Team == CombatTeam.Enemy)
                {
                    EnemiesKilled++;
                    // Spawn small reinforcements for pacing
                    SpawnReinforcements(CombatTeam.Enemy, 2);
                }
                else if (victim.Team == CombatTeam.Player && victim != _player)
                {
                    AlliesLost++;
                    SpawnReinforcements(CombatTeam.Player, 2);
                }
            };

            CombatSystem.OnDamageDealt += (attacker, target, damage) =>
            {
                // Lightweight hook for SFX/VFX/analytics; keep handlers small.
            };
        }

        // Per-frame update called by Game1.Update
        public void Update(GameTime gameTime)
        {
            Viewport vp = _gameOwnedBy.GraphicsDevice.Viewport;

            if (!_battleStarted)
            {
                // Pre-battle: let player roam and inspect the level
                _player.Update(gameTime, _levelManager.CurrentLevel, _enemies);

                // Quick demo input to start battle
                if (Keyboard.GetState().IsKeyDown(Keys.D))
                {
                    _battleStarted = true;
                }
            }
            else
            {
                UpdateBattle(gameTime, vp);
            }
        }

        // Main battle loop: update camera, player, level, spells, allies and enemies.
        private void UpdateBattle(GameTime gameTime, Viewport vp)
        {
            // Smoothly move camera zoom toward 1.0
            _camera.Zoom = MathHelper.Lerp(_camera.Zoom, 1.0f, 0.05f);

            // Update player first so others react to player's new state this same frame
            _player.Update(gameTime, _levelManager.CurrentLevel, _enemies);

            // Update level objects
            _levelManager.Update(gameTime, _player);

            _player.DamageMultiplier = GlobalPlayerDamageMult;

            // Handle periodic target scanning
            _targetingTimer += (float)gameTime.ElapsedGameTime.TotalMilliseconds;
            bool scanNow = _targetingTimer >= GameConstants.TargetScanInterval;
            if (scanNow) _targetingTimer = 0;

            _spellManager.Update(gameTime);

            UpdateAllies(gameTime, scanNow);
            UpdateEnemies(gameTime, scanNow);

            CleanupDead();

            // Keep camera centered on the player this frame
            _camera.follow(_player.CentrePos, vp);
        }

        // Update allies: optionally find targets then update AI/animations
        private void UpdateAllies(GameTime gameTime, bool scanForTargets)
        {
            foreach (var ally in _allies)
            {
                if (!ally.IsActive) continue;

                if (scanForTargets && NeedsNewTarget(ally))
                {
                    var target = FindBestTarget(ally, _enemies.Cast<ICombatant>());
                    if (target != null)
                    {
                        CombatSystem.AssignTarget(ally, target);
                        ally.CurrentAIState = Enemy.AISTATE.Chasing;
                    }
                }

                ally.Update(gameTime, _levelManager.MapObjects);
            }
        }

        // Update enemies: optionally assign target (player or allies) then update with map obstacles
        private void UpdateEnemies(GameTime gameTime, bool scanForTargets)
        {
            foreach (var enemy in _enemies)
            {
                if (!enemy.IsActive) continue;

                if (scanForTargets && NeedsNewTarget(enemy))
                {
                    var potentialTargets = new List<ICombatant> { _player };
                    potentialTargets.AddRange(_allies.Cast<ICombatant>());

                    var target = FindBestTarget(enemy, potentialTargets);
                    if (target != null)
                    {
                        CombatSystem.AssignTarget(enemy, target);
                        enemy.CurrentAIState = Enemy.AISTATE.Chasing;
                    }
                }

                enemy.Update(gameTime, _levelManager.MapObjects);
            }
        }

        // Simple validity check: needs a new target if none or current target is invalid
        private bool NeedsNewTarget(ICombatant combatant)
        {
            return combatant.CurrentTarget == null ||
                   !CombatSystem.IsValidTarget(combatant, combatant.CurrentTarget);
        }

        // Greedy nearest-target selection that respects max attackers per target
        private ICombatant FindBestTarget(ICombatant seeker, IEnumerable<ICombatant> candidates)
        {
            ICombatant best = null;
            float closestDistance = float.MaxValue;

            foreach (var candidate in candidates)
            {
                if (!CombatSystem.IsValidTarget(seeker, candidate))
                    continue;

                if (candidate.AttackerCount >= GameConstants.MaxAttackersPerTarget)
                    continue;

                float distance = CombatSystem.GetDistance(seeker, candidate);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    best = candidate;
                }
            }

            return best;
        }

        // Remove dead entries from runtime lists
        private void CleanupDead()
        {
            _allies.RemoveAll(a => a.LifecycleState == Ally.ALLYSTATE.DEAD);
            _enemies.RemoveAll(e => e.LifecycleState == Enemy.ENEMYSTATE.DEAD);
        }

        // Spawn reinforcements around the map (uses shared RNG utilities)
        private void SpawnReinforcements(CombatTeam team, int count)
        {
            Vector2 center = new Vector2(_mapSize.X / 2, _mapSize.Y / 2);
            float spawnRadius = 1800f;

            if (!SpawningBlocked)
            {
                for (int i = 0; i < count; i++)
                {
                    float angle = CombatSystem.RandomFloat(0, MathHelper.TwoPi);
                    Vector2 spawnPos = center + new Vector2(
                        (float)Math.Cos(angle) * spawnRadius,
                        (float)Math.Sin(angle) * spawnRadius
                    );

                    if (team == CombatTeam.Enemy)
                    {
                        int roll = CombatSystem.RandomInt(0, 100);
                        int typeIndex = 0;

                        if (roll >= 90) typeIndex = 2;
                        else if (roll >= 60) typeIndex = 1;
                        else typeIndex = 0;

                        var newEnemy = new Enemy(_gameOwnedBy, _allOrcTypes[typeIndex], spawnPos, 4);

                        if (typeIndex == 0) { newEnemy.Name = "Reinforcement Grunt"; newEnemy.AttackDamage = 10; }
                        if (typeIndex == 1) { newEnemy.Name = "Reinforcement Warrior"; newEnemy.AttackDamage = 20; }
                        if (typeIndex == 2) { newEnemy.Name = "Reinforcement Captain"; newEnemy.AttackDamage = 35; newEnemy.Scale = 3.5f; }

                        // Immediately assign player as target so they behave aggressively on spawn
                        CombatSystem.AssignTarget(newEnemy, _player);
                        newEnemy.CurrentAIState = Enemy.AISTATE.Chasing;

                        _enemies.Add(newEnemy);
                    }
                    else if (team == CombatTeam.Player)
                    {
                        var newAlly = new Ally(_gameOwnedBy, _allyTextures, spawnPos, 4);
                        newAlly.Name = "Reinforcement Soldier";

                        var bestTarget = FindBestTarget(newAlly, _enemies.Cast<ICombatant>());
                        if (bestTarget != null)
                        {
                            CombatSystem.AssignTarget(newAlly, bestTarget);
                            newAlly.CurrentAIState = Enemy.AISTATE.Chasing;
                        }

                        _allies.Add(newAlly);
                    }
                }
            }
        }

        // Expose SpellManager for external UI or systems
        public SpellManager GetSpellManager() => _spellManager;

        // Draw: level first, then gather sprites, sort by bottom-Y and draw in that order.
        public void Draw(GameTime gameTime, SpriteBatch spriteBatch)
        {
            _levelManager.Draw(spriteBatch);

            List<Sprite> renderList = new List<Sprite>();

            if (_player.Visible) renderList.Add(_player);

            foreach (var ally in _allies)
            {
                if (ally.Visible) renderList.Add(ally);
            }

            foreach (var enemy in _enemies)
            {
                if (enemy.Visible) renderList.Add(enemy);
            }

            foreach (var obj in _levelManager.MapObjects)
            {
                if (obj.Visible) renderList.Add(obj);
            }

            // Painter's algorithm ordering by sprite bottom Y for simple depth illusion
            renderList.Sort((a, b) =>
            {
                float aY = a.position.Y + (a.spriteHeight * (float)a.Scale);
                float bY = b.position.Y + (b.spriteHeight * (float)b.Scale);
                return aY.CompareTo(bY);
            });

            foreach (var sprite in renderList)
            {
                sprite.Draw(spriteBatch);
            }
            _spellManager.Draw(spriteBatch);
        }

        // Small helpers for external queries
        public Player GetPlayer() => _player;
        public int AllyCount => _allies.Count(a => a.IsAlive);
        public int EnemyCount => _enemies.Count(e => e.IsAlive);
        public bool IsBattleOver => _enemies.Count == 0 || !_player.IsAlive;
    }
}
//using GP01Week11Lab12025;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    // Simple tile-aligned collider used by the level to mark solid/interactive tiles.
    // - LevelManager creates these for tiles that should block movement or be visible for debugging.
    // - Other systems read CollisionField to test collisions against actors (Player, Enemy).
    public class Collider
    {
        // Tile grid coordinates (column/row) this collider sits on.
        public int tileX;
        public int tileY;

        // The texture used when drawing the collider (often a 1x1 white texture or a debug sprite).
        public Texture2D texture;

        // Toggle drawing for debug/visualization (LevelManager or editor can turn this on).
        public bool Visible = false;

        // WorldPosition: top-left world coordinate (pixels) calculated from tile indices and the texture size.
        // Consumers use this when placing or snapping objects to the same tile grid.
        public Vector2 WorldPosition
        {
            get
            {
                return new Vector2(tileX * texture.Width, tileY * texture.Height);
            }
        }

        // CollisionField: rectangle in world space used for intersection tests with sprites.
        // Use this when checking overlaps with actor bounding boxes.
        public Rectangle CollisionField
        {
            get
            {
                return new Rectangle(WorldPosition.ToPoint(), new Point(texture.Width, texture.Height));
            }
        }

        // Constructor: assign texture and tile coordinates.
        // Typical caller: LevelManager when parsing a tilemap and creating colliders for blocked tiles.
        public Collider(Texture2D tx, int tlx, int tly)
        {
            texture = tx;
            tileX = tlx;
            tileY = tly;
        }

        // Draw the collider rectangle (only when Visible is true).
        // Useful for debugging collision maps; SpriteBatch is provided by the calling draw loop.
        public void Draw(SpriteBatch sp)
        {
            if (Visible)
                sp.Draw(texture, CollisionField, Color.White);
        }
    }
}
using System;
using Microsoft.Xna.Framework;

namespace Pale_Roots_1
{
    // Shared numeric constants used across the project (speeds, ranges, timeouts, map size).
    // Consumers: Player, Enemy, Projectile, Camera, AI and other systems read these values.
    public static class GameConstants
    {
        public const float SwordSwingDuration = 250f;
        public const float SwordCooldown = 500f;
        public const int SwordDamage = 25;
        public const float SwordRange = 60f;
        public const float SwordKnockback = 15f;
        public const float SwordArcWidth = 60f;

        public const float MeleeAttackRange = 85f;
        public const float CombatEngageRange = 70f;
        public const float CombatBreakRange = 100f;
        public const float DefaultDetectionRadius = 400f;
        public const float DefaultChaseRadius = 200f;

        public const int DefaultHealth = 100;
        public const int DefaultMeleeDamage = 15;
        public const float DefaultAttackCooldown = 1000f;
        public const float TargetScanInterval = 500f;
        public const int MaxAttackersPerTarget = 2;

        public const float DefaultEnemySpeed = 3.0f;
        public const float DefaultAllySpeed = 3.0f;
        public const float DefaultPlayerSpeed = 4.0f;
        public const float ChargingSpeed = 3.0f;

        public const float DefaultProjectileSpeed = 4.0f;
        public const float DefaultReloadTime = 2000f;
        public const float ExplosionDuration = 1000f;

        public const int DeathCountdown = 30;
        public const int WanderRadius = 300;
        public const float KnockbackFriction = 0.9f;

        public const int TileSize = 64;
        public static readonly Vector2 DefaultMapSize = new Vector2(3840, 2160);
    }

    // Team tags used by CombatSystem and AI to decide friend/foe behavior.
    public enum CombatTeam
    {
        Player,
        Enemy,
        Neutral
    }

    // Minimal interface any combat-capable actor must implement so systems can interact with it.
    // Implementers: Player, Enemy, Ally, Projectile-shaping actors, etc.
    public interface ICombatant
    {
        string Name { get; }
        CombatTeam Team { get; }
        int Health { get; set; }
        int MaxHealth { get; }
        int AttackDamage { get; }
        bool IsAlive { get; }
        ICombatant CurrentTarget { get; set; }
        int AttackerCount { get; set; }
        bool IsActive { get; }
        Vector2 Position { get; }
        Vector2 Center { get; }
        void TakeDamage(int amount, ICombatant attacker);
        void PerformAttack();
        void Die();
    }

    // Centralized combat helper and bookkeeping.
    // - Resolves damage (with small variance), fires events, and keeps attacker counts consistent.
    // - Provides RNG helpers so the whole game uses one Random instance.
    public static class CombatSystem
    {
        // Events: UI, audio, spawning logic, or analytics subscribe to these.
        public static event Action<ICombatant, ICombatant, int> OnDamageDealt;
        public static event Action<ICombatant, ICombatant> OnCombatantKilled;
        public static event Action<ICombatant, ICombatant> OnTargetAcquired;

        // Single RNG used project-wide to avoid seed duplication issues.
        private static readonly Random _random = new Random();

        public static int RandomInt(int min, int max) => _random.Next(min, max);
        public static float RandomFloat() => (float)_random.NextDouble();
        public static float RandomFloat(float min, float max) => min + (float)_random.NextDouble() * (max - min);

        // Apply damage to target, notify listeners and handle death bookkeeping.
        public static int DealDamage(ICombatant attacker, ICombatant target, int baseDamage, float multiplier = 1.0f)
        {
            if (target == null || !target.IsAlive) return 0;
            if (baseDamage <= 0) return 0;

            int finalBase = (int)(baseDamage * multiplier);

            // Small randomness so hits vary slightly.
            float variance = RandomFloat(0.9f, 1.1f);
            int finalDamage = Math.Max(1, (int)(baseDamage * variance));

            target.TakeDamage(finalDamage, attacker);

            OnDamageDealt?.Invoke(attacker, target, finalDamage);

            if (!target.IsAlive)
            {
                HandleKill(attacker, target);
            }

            return finalDamage;
        }

        // Clear attacker bookkeeping and emit kill event.
        private static void HandleKill(ICombatant killer, ICombatant victim)
        {
            if (victim.CurrentTarget != null)
            {
                victim.CurrentTarget.AttackerCount--;
                victim.CurrentTarget = null;
            }

            victim.Die();
            OnCombatantKilled?.Invoke(killer, victim);
        }

        // Assign a new target for a combatant and maintain AttackerCount on the target.
        // Emits OnTargetAcquired so UI/AI can react.
        public static void AssignTarget(ICombatant combatant, ICombatant newTarget)
        {
            if (combatant == null) return;

            if (combatant.CurrentTarget != null && combatant.CurrentTarget != newTarget)
            {
                combatant.CurrentTarget.AttackerCount--;
            }

            combatant.CurrentTarget = newTarget;

            if (newTarget != null)
            {
                newTarget.AttackerCount++;
                OnTargetAcquired?.Invoke(combatant, newTarget);
            }
        }

        // Remove whatever target a combatant currently has and update counts.
        public static void ClearTarget(ICombatant combatant)
        {
            if (combatant?.CurrentTarget != null)
            {
                combatant.CurrentTarget.AttackerCount--;
                combatant.CurrentTarget = null;
            }
        }

        // True if teams differ and neither is Neutral.
        public static bool AreEnemies(ICombatant a, ICombatant b)
        {
            if (a == null || b == null) return false;
            return a.Team != b.Team && a.Team != CombatTeam.Neutral && b.Team != CombatTeam.Neutral;
        }

        // Checks that the target is alive, active and an enemy.
        public static bool IsValidTarget(ICombatant attacker, ICombatant target)
        {
            if (target == null) return false;
            if (!target.IsAlive) return false;
            if (!target.IsActive) return false;
            if (!AreEnemies(attacker, target)) return false;
            return true;
        }

        // Distance-based attack range check using entity centers.
        public static bool CanAttack(ICombatant attacker, ICombatant target, float range = -1)
        {
            if (!IsValidTarget(attacker, target)) return false;

            if (range < 0) range = GameConstants.MeleeAttackRange;

            float distance = Vector2.Distance(attacker.Center, target.Center);
            return distance <= range;
        }

        // Utility used by targeting logic to choose nearest candidates.
        public static float GetDistance(ICombatant a, ICombatant b)
        {
            if (a == null || b == null) return float.MaxValue;
            return Vector2.Distance(a.Center, b.Center);
        }

        // Helper to remove external event handlers (useful during teardown/tests).
        public static void ClearAllEvents()
        {
            OnDamageDealt = null;
            OnCombatantKilled = null;
            OnTargetAcquired = null;
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Pale_Roots_1
{
    // Simple on-screen health bar helper.
    // - Not tied to Enemy/Player directly; stores its own health value and draws a colored rectangle.
    // - Uses a 1x1 white Texture2D to render the bar (scaled to width = health).
    public class Healthbar
    {
        // Current health value (also used as bar width in pixels in this simple implementation).
        public int health;

        // 1x1 texture used to draw the colored bar. Created in the constructor.
        private Texture2D TxHealthBar;

        // Backing rectangle (not used directly by drawing code because the property builds it on the fly).
        Rectangle healthRect;

        // Screen-space position where the bar is drawn (top-left).
        public Vector2 position;

        // Property that constructs a Rectangle sized to `health` and fixed height.
        // - Getter creates a Rectangle from `position` and `health`.
        // - Setter preserves API compatibility but is not used elsewhere in the codebase.
        public Rectangle 
            HealthRect { 
            get => new Rectangle((int)position.X, (int)position.Y, health, 10);
            set => healthRect = value; }

        // Constructor:
        // - Startposition: where to draw the bar on screen.
        // - healthValue: initial health (also determines bar width).
        // - Game g: used to create the Texture2D via the GraphicsDevice.
        public Healthbar(Vector2 Startposition, int healthValue, Game g)
        {
            health = healthValue;
            position = Startposition;

            // Create a shared 1x1 white pixel texture used to draw colored rectangles.
            TxHealthBar = new Texture2D(g.GraphicsDevice, 1, 1);
            TxHealthBar.SetData(new[] { Color.White });
        }

        // Simple update for testing: reduce health if Down key is held.
        // In the real game you would call TakeDamage on an ICombatant and update this value accordingly.
        public void Update()
        {
            if (health > 0)
            {
                if (Keyboard.GetState().IsKeyDown(Keys.Down)) health--;
            }
        }

        // Draw the health bar using SpriteBatch:
        // - Green when high, Orange at medium, Red when low.
        // - Width is the numeric `health` value (so scale your health range accordingly).
        public void draw(SpriteBatch spriteBatch)
        {
            if (health > 0)
            {
                if (health > 60)
                    spriteBatch.Draw(TxHealthBar, HealthRect, Color.Green);
                else if (health > 30 && health <= 60)
                    spriteBatch.Draw(TxHealthBar, HealthRect, Color.Orange);
                else if (health > 0 && health < 30)
                    spriteBatch.Draw(TxHealthBar, HealthRect, Color.Red);
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    public static class  Helper
    {
        public static Texture2D SpriteSheet { get; set; }

        public static Dictionary<string, Rectangle> SourceRects = new Dictionary<string, Rectangle>()
        {
            { "Big_Rock", new Rectangle(16, 192, 64, 64)},
            { "Skull_Pile", new Rectangle(15, 433, 80, 60)},

            { "Tree_Dead_Large", new Rectangle(16, 16, 112, 128)},

            { "HealthBar_Border", new Rectangle(0, 0, 1, 1)},

            { "Ruins_Column", new Rectangle(7, 11, 89, 102) },

            { "Shrine_Blue", new Rectangle(0, 128, 32, 48) },
            { "Bird_Skull", new Rectangle(16, 332, 51, 52) },
            { "Skellington", new Rectangle(64, 320, 159, 119) },
            { "Bone_In_Floor", new Rectangle(560, 432, 31, 50) },
            { "Dying_Tree", new Rectangle(415, 496, 69, 93) },
            { "Hand_In_Floor", new Rectangle(608, 523, 63, 71) },
            { "Baby_Skellington", new Rectangle(239, 227, 32, 24) },

            { "Grave_1", new Rectangle(271, 683, 32, 40) },
            { "Grave_2", new Rectangle(703, 684, 33, 33) },

            { "Smaller_Ruin", new Rectangle(108, 40, 87, 73) },
            { "Ribcage", new Rectangle(317, 221, 61, 39) },
            { "Medium_Dying_Tree", new Rectangle(83, 511, 71, 75) },
            { "Brambles_Large", new Rectangle(12, 590, 117, 84) },
            { "Brambles_Medium", new Rectangle(144, 611, 99, 60) },
            { "Brambles_Small", new Rectangle(256, 619, 63, 55) },
            { "Brambles_Tiny", new Rectangle(335, 639, 40, 28) },
            { "Brambles_Very_Tiny", new Rectangle(384, 643, 16, 23) },

            { "Grave_3", new Rectangle(80, 722, 31, 24) },
            { "Small_Dying_Tree", new Rectangle(544, 539, 50, 55) },
            { "Hand_In_Floor_Medium", new Rectangle(271, 531, 48, 55) },
            { "Hand_In_Floor_Small", new Rectangle(320, 531, 31, 55) },
            { "Hand_In_Floor_Tiny", new Rectangle(352, 542, 33, 48) },


        };

        public static Rectangle GetSourceRect(string key)
        {
            if (SourceRects.ContainsKey(key))
            {
                return SourceRects[key];
            }
            return new Rectangle(0, 0, 32, 32);

        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Input.Touch;
#if ANDROID
using Microsoft.Devices.Sensors;
#endif

namespace Pale_Roots_1
{
    // InputEngine: centralizes input polling for keyboard, gamepad, mouse and (optionally) touch/accelerometer.
    // - Added as a GameComponent so it's automatically updated by Game1.
    // - Other systems call static helpers (IsKeyPressed, IsButtonHeld, MousePosition, etc.) instead of reading raw platform APIs.
    // - Keeps previous/current states to detect presses vs holds vs releases.
    public class InputEngine : GameComponent
    {
        // GamePad state tracking
        private static GamePadState previousPadState;
        private static GamePadState currentPadState;

        // Keyboard state tracking
        private static KeyboardState previousKeyState;
        private static KeyboardState currentKeyState;

        // Mouse position and state (Windows only)
        private static Vector2 previousMousePos;
        private static Vector2 currentMousePos;
        private static MouseState previousMouseState;
        private static MouseState currentMouseState;

#if ANDROID
        // Mobile-only input fields: accelerometer and touch gesture info
        private static Vector2 previousAccelerometerReading;
        private static Accelerometer _acceleromter;
        private static Vector2 currentAcceleromoterReading;
        private static Point touchPoint;
        private static GestureType currentGestureType;

        // Accelerometer event handler updates cached readings (orientation assumed landscape here).
        private void _acceleromter_CurrentValueChanged(object sender, SensorReadingEventArgs<AccelerometerReading> e)
        {
            previousAccelerometerReading = CurrentAcceleromoterReading;
            currentAcceleromoterReading.Y = -(float)e.SensorReading.Acceleration.Y;
            currentAcceleromoterReading.X = -(float)e.SensorReading.Acceleration.X;
        }
#endif

        // Register the component and initialize current states.
        public InputEngine(Game _game)
            : base(_game)
        {
            currentPadState = GamePad.GetState(PlayerIndex.One);
            currentKeyState = Keyboard.GetState();

#if ANDROID
            _acceleromter = new Accelerometer();
            _acceleromter.CurrentValueChanged += _acceleromter_CurrentValueChanged;
            _acceleromter.Start();
            TouchPanel.EnabledGestures =
                    GestureType.Hold |
                    GestureType.Tap |
                    GestureType.DoubleTap |
                    GestureType.FreeDrag |
                    GestureType.Flick |
                    GestureType.Pinch;
#endif

            _game.Components.Add(this);
        }

        // Reset cached states (useful when changing scenes or pausing).
        public static void ClearState()
        {
            previousMouseState = Mouse.GetState();
            currentMouseState = Mouse.GetState();
            previousKeyState = Keyboard.GetState();
            currentKeyState = Keyboard.GetState();
#if ANDROID
            currentGestureType = GestureType.None;
#endif
        }

        // Called each frame by the GameComponent system.
        // - Updates previous/current snapshots.
        // - Collects simple text-key presses for UI input.
        // - Handles touch input when compiled for Android.
        public override void Update(GameTime gametime)
        {
            previousPadState = currentPadState;
            previousKeyState = currentKeyState;

            currentPadState = GamePad.GetState(PlayerIndex.One);
            currentKeyState = Keyboard.GetState();

#if WINDOWS
            previousMouseState = currentMouseState;
            currentMousePos = new Vector2(Mouse.GetState().X, Mouse.GetState().Y);
            currentMouseState = Mouse.GetState();
#endif

            KeysPressedInLastFrame.Clear();
            CheckForTextInput();
#if ANDROID
            HandleTouchInput();
#endif
            base.Update(gametime);
        }

        // Simple list used by UI or consoles to obtain the first textual key pressed this frame.
        public List<string> KeysPressedInLastFrame = new List<string>();

        // Scan all Keys and add the first pressed key (useful for single-key text input).
        private void CheckForTextInput()
        {
            foreach (var key in Enum.GetValues(typeof(Keys)) as Keys[])
            {
                if (IsKeyPressed(key))
                {
                    KeysPressedInLastFrame.Add(key.ToString());
                    break;
                }
            }
        }

        // GamePad helpers
        public static bool IsButtonPressed(Buttons buttonToCheck)
        {
            // true when transitioned from down -> up in the last frame
            if (currentPadState.IsButtonUp(buttonToCheck) && previousPadState.IsButtonDown(buttonToCheck))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        public static bool IsButtonHeld(Buttons buttonToCheck)
        {
            return currentPadState.IsButtonDown(buttonToCheck);
        }

        // Keyboard helpers
        public static bool IsKeyHeld(Keys buttonToCheck)
        {
            return currentKeyState.IsKeyDown(buttonToCheck);
        }

        public static bool IsKeyPressed(Keys keyToCheck)
        {
            // Note: this implementation treats pressed as previous down -> current up (edge detection).
            if (currentKeyState.IsKeyUp(keyToCheck) && previousKeyState.IsKeyDown(keyToCheck))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        // Expose raw current states to other systems when needed.
        public static GamePadState CurrentPadState
        {
            get { return currentPadState; }
            set { currentPadState = value; }
        }
        public static KeyboardState CurrentKeyState
        {
            get { return currentKeyState; }
        }

        public static MouseState CurrentMouseState
        {
            get { return currentMouseState; }
        }

        public static MouseState PreviousMouseState
        {
            get { return previousMouseState; }
        }

#if ANDROID
        // Android touch/accelerometer accessors
        public static Point TouchPoint
        {
            get { return touchPoint; }
            set { touchPoint = value; }
        }

        public static GestureType CurrentGestureType
        {
            get
            {
                GestureType ret = currentGestureType;
                currentGestureType = GestureType.None; // consume once
                return ret;
            }

            set
            {
                currentGestureType = value;
            }
        }

        public static Vector2 CurrentAcceleromoterReading
        {
            get { return currentAcceleromoterReading; }
            set { currentAcceleromoterReading = value; }
        }

        // Process queued touch gestures from TouchPanel and update touchPoint/currentGestureType.
        private void HandleTouchInput()
        {
            TouchCollection touches = TouchPanel.GetState();
            while (TouchPanel.IsGestureAvailable)
            {
                GestureSample gesture = TouchPanel.ReadGesture();
                if (touches.Count > 0 && touches[0].State == TouchLocationState.Pressed)
                {
                    touchPoint = new Point((int)touches[0].Position.X, (int)touches[0].Position.Y);
                }

                switch (gesture.GestureType)
                {
                    case GestureType.Tap:
                        currentGestureType = GestureType.DoubleTap;
                        touchPoint = new Point((int)gesture.Position.X, (int)gesture.Position.Y);
                        break;
                    case GestureType.DoubleTap:
                        touchPoint = new Point((int)gesture.Position.X, (int)gesture.Position.Y);
                        currentGestureType = GestureType.DoubleTap;
                        break;
                    case GestureType.Hold:
                        break;
                    case GestureType.FreeDrag:
                        break;
                    case GestureType.Flick:
                        break;
                    case GestureType.Pinch:
                        // Example: compute scale change from pinch delta (not applied here).
                        Vector2 a = gesture.Position;
                        Vector2 aOld = gesture.Position - gesture.Delta;
                        Vector2 b = gesture.Position2;
                        Vector2 bOld = gesture.Position2 - gesture.Delta2;
                        float d = Vector2.Distance(a, b);
                        float dOld = Vector2.Distance(aOld, bOld);
                        float scaleChange = (d - dOld) * .01f;
                        break;
                }
            }

        }

#endif

#if WINDOWS
        // Mouse helpers (edge detection using previous/current MouseState)
        public static bool IsMouseLeftClick()
        {
            if (currentMouseState.LeftButton == ButtonState.Released && previousMouseState.LeftButton == ButtonState.Pressed)
                return true;
            else 
                return false;
        }

        public static bool IsMouseRightClick()
        {
            if (currentMouseState.RightButton == ButtonState.Released && previousMouseState.RightButton == ButtonState.Pressed)
                return true;
            else
                return false;
        }

        public static bool IsMouseRightHeld()
        {
            if (currentMouseState.RightButton == ButtonState.Pressed && previousMouseState.RightButton == ButtonState.Pressed)
                return true;
            else
                return false;
        }

        public static bool IsMouseLeftHeld()
        {
            if (currentMouseState.LeftButton == ButtonState.Pressed && previousMouseState.LeftButton == ButtonState.Pressed)
                return true;
            else
                return false;
        }

        // Current mouse position in screen coordinates (updated in Update).
        public static Vector2 MousePosition
        {
            get { return currentMousePos; }
        }
#endif



    }
}
using System;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;

namespace Pale_Roots_1
{
    // Projectile: simple reusable projectile that moves toward a target, then plays an explosion sprite and sound.
    // - Inherits rotation/movement helpers from RotatingSprite (TurnToFace, Follow, MoveToward, etc.).
    // - Uses an external Sprite instance for the explosion so the visual effect can be animated separately.
    // - Typical usage: create one Projectile, call Load/assign it to a Sentry/Enemy, call fire(target) to launch.
    public class Projectile : RotatingSprite
    {
        // Projectile lifecycle states.
        public enum PROJECTILE_STATE { STILL, FIRING, EXPOLODING };

        // Backing state field; controls Update() behavior.
        PROJECTILE_STATE projectileState = PROJECTILE_STATE.STILL;

        // Reference to the game for content access (sound).
        protected Game myGame;

        // How fast the projectile moves; used as a multiplier in the Lerp step.
        protected float RocketVelocity = 4.0f;

        // Precomputed half-size used to offset explosion sprite.
        Vector2 textureCenter;

        // Target world position the projectile moves toward.
        Vector2 Target;

        // Explosion visual handled by a separate Sprite (AnimationManager on that sprite will run independently).
        Sprite explosion;

        // Explosion timing: how long the explosion is visible before resetting to STILL.
        float ExplosionTimer = 0;
        float ExplosionVisibleLimit = 1000;

        // Where the projectile started (useful if you want to reset it later).
        Vector2 StartPosition;

        // Explosion sound effect loaded from Content.
        private SoundEffect explosionSound;

        // Public accessors for state and the explosion sprite.
        public PROJECTILE_STATE ProjectileState
        {
            get { return projectileState; }
            set { projectileState = value; }
        }

        public Sprite Explosion
        {
            get { return explosion; }
            set { explosion = value; }
        }

        // Constructor:
        // - texture: projectile image
        // - rocketExplosion: a Sprite instance used to render the explosion animation
        // - userPosition: spawn position for the projectile
        // - framecount: frames for the projectile (passed to base)
        public Projectile(Game g, Texture2D texture, Sprite rocketExplosion, Vector2 userPosition, int framecount)
            : base(g, texture, userPosition, framecount)
        {
            Target = Vector2.Zero;
            myGame = g;

            // store half-size so we can position the explosion origin sensibly
            textureCenter = new Vector2(texture.Width / 2, texture.Height / 2);

            explosion = rocketExplosion;

            // Offset explosion sprite so its position lines up with projectile visually.
            explosion.position -= textureCenter;
            explosion.Visible = false;

            StartPosition = position;
            ProjectileState = PROJECTILE_STATE.STILL;

            // Load an explosion SFX from Content (file name must exist in your Content).
            explosionSound = myGame.Content.Load<SoundEffect>("explosion");
        }

        // Per-frame logic:
        // - STILL: hide projectile/explosion
        // - FIRING: move toward Target and rotate to face it
        // - EXPOLODING: show explosion sprite and play sound
        public override void Update(GameTime gametime)
        {
            switch (projectileState)
            {
                case PROJECTILE_STATE.STILL:
                    // Hidden and idle while still.
                    this.Visible = false;
                    explosion.Visible = false;
                    break;

                case PROJECTILE_STATE.FIRING:
                    // Make projectile visible and step toward target.
                    this.Visible = true;

                    // Using Lerp to move smoothly toward the target; RocketVelocity scales the lerp speed.
                    position = Vector2.Lerp(position, Target, 0.02f * RocketVelocity);

                    // Rotate to face travel direction using the helper on RotatingSprite.
                    this.angleOfRotation = TurnToFace(position, Target, angleOfRotation, 1f);

                    // If we are very close to the target, trigger explosion state.
                    if (Vector2.Distance(position, Target) < 2)
                        projectileState = PROJECTILE_STATE.EXPOLODING;
                    break;

                case PROJECTILE_STATE.EXPOLODING:
                    // Place explosion at the impact point and show it.
                    explosion.position = Target;
                    explosion.Visible = true;

                    // Play sound once when explosion becomes visible.
                    explosionSound.Play();
                    break;
            }

            // If explosion is visible run its animation and accumulate the display timer.
            if (explosion.Visible)
            {
                explosion.Update(gametime);
                ExplosionTimer += gametime.ElapsedGameTime.Milliseconds;
            }

            // When the explosion has been visible long enough, reset everything to STILL.
            if (ExplosionTimer > ExplosionVisibleLimit)
            {
                explosion.Visible = false;
                ExplosionTimer = 0;
                projectileState = PROJECTILE_STATE.STILL;

                // Optionally reset projectile position so it can be reused from its start.
                position = StartPosition;
            }

            base.Update(gametime);
        }

        // Launch the projectile toward a world-space point.
        public void fire(Vector2 SiteTarget)
        {
            projectileState = PROJECTILE_STATE.FIRING;
            Target = SiteTarget;
        }

        // Draw projectile then explosion (explosion draws itself when visible).
        public override void Draw(SpriteBatch spriteBatch)
        {
            base.Draw(spriteBatch);

            if (explosion.Visible)
                explosion.Draw(spriteBatch);
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Pale_Roots_1
{
    static public class Utility
    {
        static Random r = new Random();

        public static int NextRandom(int max)
        {
            return r.Next(max);
        }

        public static int NextRandom(int min, int max)
        {
            return r.Next(min,max);

        }
    }
}
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Pale Roots 1")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+fa171e5067a0ff5c553ad945b89e6aba84b7a7b4")]
[assembly: System.Reflection.AssemblyProductAttribute("Pale Roots 1")]
[assembly: System.Reflection.AssemblyTitleAttribute("Pale Roots 1")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]
[assembly: System.Runtime.Versioning.TargetPlatformAttribute("Windows7.0")]
[assembly: System.Runtime.Versioning.SupportedOSPlatformAttribute("Windows7.0")]

// Generated by the MSBuild WriteCodeFragment class.

using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Pale_Roots_1
{
    // Ally: friendly combat unit that behaves like Enemy but fights for the player.
    // - Implements ICombatant so CombatSystem and ChaseAndFireEngine treat it like any actor.
    // - Uses RotatingSprite for movement/rotation helpers and AnimationManager for visuals.
    public class Ally : RotatingSprite, ICombatant
    {
        // Simple lifecycle enum for ally state
        public enum ALLYSTATE { ALIVE, DYING, DEAD }

        // Animation + facing state
        private AnimationManager _animManager;
        private int _currentDirectionIndex = 1;
        private SpriteEffects _flipEffect = SpriteEffects.None;

        // Shared 1x1 texture used to draw the ally's health bar
        private static Texture2D _healthBarTexture;
        private bool _drawHealthBar = true;

        // Lifecycle backing field and property
        private ALLYSTATE _lifecycleState = ALLYSTATE.ALIVE;
        public ALLYSTATE LifecycleState
        {
            get => _lifecycleState;
            set => _lifecycleState = value;
        }

        // ICombatant surface (used by CombatSystem and engine)
        public string Name { get; set; } = "Ally";
        public CombatTeam Team => CombatTeam.Player;
        public int MaxHealth { get; protected set; }
        public int AttackDamage { get; protected set; }
        public bool IsAlive => Health > 0 && _lifecycleState == ALLYSTATE.ALIVE;
        public bool IsActive => Visible && _lifecycleState != ALLYSTATE.DEAD;

        // Target bookkeeping (keeps a Sprite reference for visual sync)
        private ICombatant _currentTarget;
        public ICombatant CurrentTarget
        {
            get => _currentTarget;
            set
            {
                _currentTarget = value;
                CurrentCombatPartner = value as Sprite;
            }
        }

        // Position/movement fields used by RotatingSprite and AI
        public Vector2 Position => position;
        protected float Velocity;
        protected Vector2 startPosition;
        protected Vector2 wanderTarget;
        private float _attackCooldown = 0f;
        private int _deathCountdown;

        // Constructor: sets stats, animations and initial AI state (mirrors Enemy pattern)
        public Ally(Game g, Dictionary<string, Texture2D> textures, Vector2 userPosition, int framecount)
            : base(g, textures["Walk"], userPosition, framecount)
        {
            startPosition = userPosition;
            Velocity = GameConstants.DefaultAllySpeed;
            MaxHealth = GameConstants.DefaultHealth;
            Health = MaxHealth;
            AttackDamage = GameConstants.DefaultMeleeDamage;
            _deathCountdown = GameConstants.DeathCountdown;
            CurrentAIState = Enemy.AISTATE.Charging;

            Scale = 3.0f;
            _animManager = new AnimationManager();

            // Register animations using the supplied atlas dictionary
            _animManager.AddAnimation("Idle", new Animation(textures["Idle"], 4, 0, 200f, true, 4, 0, true));
            _animManager.AddAnimation("Walk", new Animation(textures["Walk"], 4, 0, 125f, true, 4, 0, true));
            _animManager.AddAnimation("Attack", new Animation(textures["Attack"], 6, 0, 175f, false, 4, 0, true));

            _animManager.Play("Idle");

            // Create the health-bar texture once for all allies
            if (_healthBarTexture == null)
            {
                _healthBarTexture = new Texture2D(g.GraphicsDevice, 1, 1);
                _healthBarTexture.SetData(new[] { Color.White });
            }
        }

        // High-level update: run base update, choose animation and handle dying
        public override void Update(GameTime gametime)
        {
            base.Update(gametime);
            UpdateDirection();

            string animKey = "Idle";
            if (CurrentAIState == Enemy.AISTATE.InCombat && _attackCooldown > 800)
                animKey = "Attack";
            else if (Velocity > 0.1f || CurrentAIState == Enemy.AISTATE.Charging)
                animKey = "Walk";

            _animManager.Play(animKey);
            _animManager.Update(gametime);

            if (_lifecycleState == ALLYSTATE.DYING) UpdateDying(gametime);
        }

        // Frame update that includes obstacle-aware AI behavior (called by engine)
        public void Update(GameTime gametime, List<WorldObject> obstacles)
        {
            this.Update(gametime);
            if (_lifecycleState == ALLYSTATE.ALIVE)
            {
                UpdateAI(gametime, obstacles);
            }
        }

        // AI tick: handle cooldowns, validate targets, and dispatch to state handlers
        protected virtual void UpdateAI(GameTime gameTime, List<WorldObject> obstacles)
        {
            if (_attackCooldown > 0) _attackCooldown -= (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            if (_currentTarget != null && !CombatSystem.IsValidTarget(this, _currentTarget))
            {
                CombatSystem.ClearTarget(this);
                CurrentAIState = Enemy.AISTATE.Wandering;
            }

            switch (CurrentAIState)
            {
                case Enemy.AISTATE.Charging: PerformCharge(obstacles); break;
                case Enemy.AISTATE.Chasing: PerformChase(obstacles); break;
                case Enemy.AISTATE.InCombat: PerformCombat(gameTime); break;
                case Enemy.AISTATE.Wandering: PerformWander(obstacles); break;
            }
        }

        // Charge movement: ally moves right (game convention differs from Enemy)
        protected virtual void PerformCharge(List<WorldObject> obstacles)
        {
            position.X += Velocity;
            Vector2 target = new Vector2(position.X - 1000, position.Y);
            MoveToward(target, Velocity, obstacles);
        }

        // Chase current target using MoveToward (handles obstacle sliding). Switch to InCombat when close.
        protected virtual void PerformChase(List<WorldObject> obstacles)
        {
            if (_currentTarget == null) { CurrentAIState = Enemy.AISTATE.Wandering; return; }
            MoveToward(_currentTarget.Center, Velocity, obstacles);
            if (CombatSystem.GetDistance(this, _currentTarget) < GameConstants.CombatEngageRange)
                CurrentAIState = Enemy.AISTATE.InCombat;
        }

        // Combat loop: face target, attack if in range and off-cooldown, break if target flees.
        protected virtual void PerformCombat(GameTime gameTime)
        {
            if (_currentTarget == null || !_currentTarget.IsAlive) { CurrentAIState = Enemy.AISTATE.Wandering; return; }
            SnapToFace(_currentTarget.Center);
            if (CombatSystem.GetDistance(this, _currentTarget) < GameConstants.MeleeAttackRange && _attackCooldown <= 0)
                PerformAttack();
            if (CombatSystem.GetDistance(this, _currentTarget) > GameConstants.CombatBreakRange)
                CurrentAIState = Enemy.AISTATE.Chasing;
        }

        // Wander: pick a random point around the start and MoveToward it slowly
        protected virtual void PerformWander(List<WorldObject> obstacles)
        {
            if (wanderTarget == Vector2.Zero || Vector2.Distance(position, wanderTarget) < 5f)
            {
                wanderTarget = startPosition + new Vector2(
                    CombatSystem.RandomInt(-GameConstants.WanderRadius, GameConstants.WanderRadius + 1),
                    CombatSystem.RandomInt(-GameConstants.WanderRadius, GameConstants.WanderRadius + 1)
                );
            }
            MoveToward(wanderTarget, Velocity * 0.5f, obstacles);
        }

        // Dying countdown then mark dead and hide
        protected virtual void UpdateDying(GameTime gameTime)
        {
            _deathCountdown--;
            if (_deathCountdown <= 0) { _lifecycleState = ALLYSTATE.DEAD; Visible = false; }
        }

        // Apply damage; transition to dying/dead when health depletes
        public virtual void TakeDamage(int amount, ICombatant attacker)
        {
            if (!IsAlive) return;
            Health -= amount;
            if (Health <= 0) Die();
        }

        // Trigger melee attack animation and call CombatSystem to resolve damage
        public virtual void PerformAttack()
        {
            if (_currentTarget == null || _attackCooldown > 0) return;
            _animManager.Play("Attack");
            CombatSystem.DealDamage(this, _currentTarget, AttackDamage);
            _attackCooldown = GameConstants.DefaultAttackCooldown;
        }

        // Enter dying state and clear target bookkeeping
        public virtual void Die()
        {
            _lifecycleState = ALLYSTATE.DYING;
            _deathCountdown = GameConstants.DeathCountdown;
            CombatSystem.ClearTarget(this);
        }

        // Choose facing direction for animation based on current target or recent movement
        private void UpdateDirection()
        {
            if (CurrentTarget != null)
            {
                Vector2 diff = CurrentTarget.Position - this.Position;

                _flipEffect = SpriteEffects.None;

                if (Math.Abs(diff.X) > Math.Abs(diff.Y))
                {
                    _currentDirectionIndex = (diff.X < 0) ? 0 : 1;
                }
                else
                {
                    _currentDirectionIndex = (diff.Y < 0) ? 2 : 3;
                }
            }
            else if (Velocity > 0.1f)
            {
                // keep current direction when moving
            }
        }

        // Draw animation and a small health bar above the ally
        public override void Draw(SpriteBatch spriteBatch)
        {
            if (Visible)
                _animManager.Draw(spriteBatch, position, (float)Scale, _flipEffect, _currentDirectionIndex);
            if (_drawHealthBar && IsAlive)
                DrawHealthBar(spriteBatch);
        }

        // Health bar rendering: red background, colored foreground based on health percent
        protected virtual void DrawHealthBar(SpriteBatch spriteBatch)
        {
            int barWidth = spriteWidth;
            int barHeight = 5;
            int barX = (int)position.X - (barWidth / 2);
            int barY = (int)position.Y - spriteHeight / 2 - 10;
            spriteBatch.Draw(_healthBarTexture, new Rectangle(barX, barY, barWidth, barHeight), Color.Red);
            float healthPercent = (float)Health / MaxHealth;
            int currentBarWidth = (int)(barWidth * healthPercent);
            spriteBatch.Draw(_healthBarTexture, new Rectangle(barX, barY, currentBarWidth, barHeight), Color.CornflowerBlue);
        }
    }
}
using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;

namespace Pale_Roots_1
{
    // Player: controllable ICombatant with movement, dash and melee attack state machine.
    // - Uses AnimationManager for visuals and GameConstants for shared tuning.
    // - Interacts with CombatSystem for damage and ChaseAndFireEngine/LevelManager for world queries.
    public class Player : Sprite, ICombatant
    {
        // ICombatant surface
        public string Name { get; set; } = "Hero";
        public float DamageMultiplier { get; set; } = 1.0f;
        public CombatTeam Team => CombatTeam.Player;

        // Cached mouse world position used for aiming attacks
        private Vector2 _mouseWorldPosition;

        // Dash timers exposed for UI
        public float DashTimer => _dashCooldownTimer;
        public float DashDuration => _dashCooldownDuration;

        // Health / combat members (MaxHealth/Health from Sprite base)
        public int MaxHealth { get; protected set; }
        public int AttackDamage { get; protected set; }
        public bool IsAlive => Health > 0;
        public bool IsActive => Visible;
        public ICombatant CurrentTarget { get; set; }
        public Vector2 Position => position;
        public Vector2 CentrePos => Center;

        // Movement & state
        private float _speed;
        private Vector2 _velocity;

        // Player state machine for movement/combat/interrupts
        public enum PlayerState
        {
            Idle,
            Run,
            Attack1,
            Attack2,
            Dash,
            Hurt,
            Dead
        }
        public PlayerState CurrentState { get; private set; } = PlayerState.Idle;

        // Facing and unlockables
        private Vector2 _facingDirection = new Vector2(0, 1);
        public bool IsHeavyAttackUnlocked { get; set; } = false;
        public bool IsDashUnlocked { get; set; } = false;

        // Dash variables
        private float _dashSpeed = 12f;
        private Vector2 _dashDirection;

        // Timers / combo buffering
        private float _stateTimer = 0f;
        private bool _comboBuffered = false;
        private float _cooldownTimer = 0f;

        // Enemies already hit this swing (prevents multi-hit per swing)
        private List<ICombatant> _enemiesHitThisAttack = new List<ICombatant>();

        // Animation / direction
        public enum Direction {Down = 0, Left = 0, Right = 2, Up = 3 }
        private Direction _currentDirection = Direction.Down;
        private int _currentDirectionIndex = 2;

        // Dash cooldown / invincibility flag during dash
        private float _dashCooldownTimer = 0f;
        private float _dashCooldownDuration = 800f;
        private bool _isInvincible = false;

        // Visual offset used when drawing (adjust to align sprite to logic position)
        private Vector2 _visualOffset = new Vector2(0, 32);

        // Per-state textures (loaded in ctor) and animation manager
        private Texture2D _txIdle;
        private Texture2D _txRun;
        private Texture2D _txAttack1;
        private Texture2D _txAttack2;
        private Texture2D _txHurt;
        private Texture2D _txDeath;
        private Texture2D _txDash;
        private AnimationManager _animManager;
        private SpriteEffects _flipEffect = SpriteEffects.None;

        // Shared 1x1 texture used for debug/health bar drawing
        private static Texture2D _healthBarTexture;

        // Constructor: load textures, set stats and register animations
        public Player(Game game, Texture2D texture, Vector2 startPosition, int frameCount)
            : base(game, texture, startPosition, frameCount, 1)
        {
            _speed = GameConstants.DefaultPlayerSpeed;
            MaxHealth = GameConstants.DefaultHealth;
            Health = MaxHealth;
            AttackDamage = GameConstants.DefaultMeleeDamage;
            Scale = 3f;

            if (_healthBarTexture == null)
            {
                _healthBarTexture = new Texture2D(game.GraphicsDevice, 1, 1);
                _healthBarTexture.SetData(new[] { Color.White });
            }

            _animManager = new AnimationManager();

            // 1. Load texture sheets from Content
            _txIdle = game.Content.Load<Texture2D>("Player/Idle");
            _txRun = game.Content.Load<Texture2D>("Player/Run");
            _txAttack1 = game.Content.Load<Texture2D>("Player/Attack 1");
            _txAttack2 = game.Content.Load<Texture2D>("Player/Attack 2");
            _txHurt = game.Content.Load<Texture2D>("Player/Hurt");
            _txDeath = game.Content.Load<Texture2D>("Player/Death");
            _txDash = game.Content.Load<Texture2D>("Player/Dash");

            // 2. Register animations (use Idle width as standard frame width for some sheets)
            int standardWidth = _txIdle.Width / 7;

            _animManager.AddAnimation("Idle", new Animation(_txIdle, 7, 0, 150f, true));
            _animManager.AddAnimation("Run", new Animation(_txRun, 8, 0, 120f, true));
            _animManager.AddAnimation("Attack1", new Animation(_txAttack1, 10, 0, 100f, false, 1, standardWidth));
            _animManager.AddAnimation("Attack2", new Animation(_txAttack2, 10, 0, 100f, false, 1, standardWidth));
            _animManager.AddAnimation("Dash", new Animation(_txDash, 4, 0, 125f, false, 1, standardWidth));
            _animManager.AddAnimation("Hurt", new Animation(_txHurt, 3, 0, 150f, false, 1, standardWidth));
            _animManager.AddAnimation("Death", new Animation(_txDeath, 15, 0, 150f, false, 1, standardWidth));

            _animManager.Play("Idle");
        }

        // Main update called by the engine each frame.
        // - currentLayer used for collision/tile checks
        // - enemies list used for attack collision tests
        public void Update(GameTime gameTime, TileLayer currentLayer, List<Enemy> enemies)
        {
            float dt = (float)gameTime.ElapsedGameTime.TotalMilliseconds;

            // Timers
            if (_cooldownTimer > 0) _cooldownTimer -= dt;
            if (_dashCooldownTimer > 0) _dashCooldownTimer -= dt;

            // Compute mouse world position from screen center and player center
            MouseState mouseState = Mouse.GetState();
            Vector2 screenCenter = new Vector2(game.GraphicsDevice.Viewport.Width / 2, game.GraphicsDevice.Viewport.Height / 2);
            Vector2 mouseOffset = new Vector2(mouseState.X, mouseState.Y) - screenCenter;
            _mouseWorldPosition = this.Center + mouseOffset;

            // State machine dispatch
            switch (CurrentState)
            {
                case PlayerState.Idle:
                case PlayerState.Run:
                    HandleInput(currentLayer, true); // allow switching Run/Idle
                    CheckForCombatInput(enemies);
                    break;

                case PlayerState.Attack1:
                case PlayerState.Attack2:
                    HandleInput(currentLayer, false); // allow movement but don't change attack state
                    UpdateAttack(gameTime, enemies, (CurrentState == PlayerState.Attack1 ? 1 : 2));
                    break;

                case PlayerState.Dash:
                    UpdateDash(gameTime, currentLayer);
                    break;

                case PlayerState.Hurt:
                    HandleInput(currentLayer, false);
                    UpdateHurt(gameTime);
                    break;

                case PlayerState.Dead:
                    break;
            }

            UpdateAnimation(gameTime);
        }

        // Check input for combat actions (dash or mouse buttons)
        private void CheckForCombatInput(List<Enemy> enemies)
        {
            KeyboardState kState = Keyboard.GetState();
            MouseState mState = Mouse.GetState();

            // Dash input
            if (IsDashUnlocked && kState.IsKeyDown(Keys.LeftShift))
            {
                StartDash();
                return;
            }

            if (_cooldownTimer > 0) return;

            // Attack input: left = light, right = heavy (if unlocked)
            if (mState.LeftButton == ButtonState.Pressed)
            {
                StartAttack(enemies, 1);
            }
            else if (IsHeavyAttackUnlocked && mState.RightButton == ButtonState.Pressed)
            {
                StartAttack(enemies, 2);
            }
        }

        // Begin dash: set invincibility, direction and timers
        private void StartDash()
        {
            if (_dashCooldownTimer > 0) return;

            CurrentState = PlayerState.Dash;
            _dashSpeed = 20f;
            _stateTimer = 150f;

            _dashCooldownTimer = _dashCooldownDuration;
            _isInvincible = true;

            // If moving, dash that direction. Otherwise dash horizontally based on facing index.
            if (_velocity != Vector2.Zero)
                _dashDirection = Vector2.Normalize(_velocity);
            else
            {
                if (_currentDirectionIndex == 2) _dashDirection = new Vector2(-1, 0);
                else _dashDirection = new Vector2(1, 0);
            }
        }

        // Dash state update: move for duration then clear invincibility
        private void UpdateDash(GameTime gameTime, TileLayer layer)
        {
            float dt = (float)gameTime.ElapsedGameTime.TotalMilliseconds;
            _stateTimer -= dt;

            position += _dashDirection * _dashSpeed;

            if (_stateTimer <= 0)
            {
                CurrentState = PlayerState.Idle;
                _velocity = Vector2.Zero;
                _isInvincible = false;
            }
        }

        // Hurt state countdown then return to Idle
        private void UpdateHurt(GameTime gameTime)
        {
            _stateTimer -= (float)gameTime.ElapsedGameTime.TotalMilliseconds;
            if (_stateTimer <= 0)
            {
                CurrentState = PlayerState.Idle;
            }
        }

        // Read WASD, set velocity and attempt movement against the tile layer.
        // updateState = false prevents state switches (used during attacks/hurt).
        private void HandleInput(TileLayer currentLayer, bool updateState)
        {
            Vector2 inputDirection = Vector2.Zero;
            KeyboardState state = Keyboard.GetState();

            if (state.IsKeyDown(Keys.W)) inputDirection.Y -= 1;
            if (state.IsKeyDown(Keys.S)) inputDirection.Y += 1;
            if (state.IsKeyDown(Keys.A)) inputDirection.X -= 1;
            if (state.IsKeyDown(Keys.D)) inputDirection.X += 1;

            if (inputDirection != Vector2.Zero)
            {
                inputDirection.Normalize();
                _facingDirection = inputDirection;
                _velocity = inputDirection * _speed;

                _currentDirectionIndex = GetDirectionFromVector(_facingDirection);

                Vector2 proposedPosition = position + _velocity;
                if (currentLayer != null && CanMoveTo(proposedPosition, currentLayer))
                {
                    position = proposedPosition;
                }
                else if (currentLayer == null)
                {
                    position = proposedPosition;
                }
            }
            else
            {
                _velocity = Vector2.Zero;
            }

            // Only change Run/Idle when allowed (prevents attack animation override).
            if (updateState)
            {
                if (_velocity != Vector2.Zero)
                    CurrentState = PlayerState.Run;
                else
                    CurrentState = PlayerState.Idle;
            }
        }

        // Map a direction vector to an animation row index
        private int GetDirectionFromVector(Vector2 dir)
        {
            if (Math.Abs(dir.X) > Math.Abs(dir.Y))
            {
                return (dir.X > 0) ? 3 : 2;
            }
            else
            {
                return (dir.Y > 0) ? 0 : 1;
            }
        }

        // Collision / tile movement check. Computes a small "feet" rectangle for passability tests.
        private bool CanMoveTo(Vector2 newPos, TileLayer layer)
        {
            float scale = (float)Scale;
            int playerW = (int)(spriteWidth * scale * 0.4f);
            int playerH = (int)(spriteHeight * scale * 0.2f);

            int playerX = (int)(newPos.X - (playerW / 2));
            int playerY = (int)(newPos.Y + (spriteHeight * scale / 2) - playerH);

            Rectangle futurePlayerBox = new Rectangle(playerX, playerY, playerW, playerH);

            float mapWidth = layer.Tiles.GetLength(1) * 64;
            float mapHeight = layer.Tiles.GetLength(0) * 64;

            // Basic bounds checks
            if (newPos.X < 0 || newPos.Y < 0) return false;
            if (newPos.X + (spriteWidth * Scale) > mapWidth) return false;
            if (newPos.Y + (spriteHeight * Scale) > mapHeight) return false;

            // Tile passability checks would go here (sample surrounding tiles using futurePlayerBox).
            // This function currently returns true (placeholder for your tile queries).
            return true;
        }

        // -----------------------
        // COMBAT
        // -----------------------

        // Initialize attack: set facing to mouse, start animation and reset hit list.
        private void StartAttack(List<Enemy> enemies, int attackNum)
        {
            Vector2 dirToMouse = _mouseWorldPosition - this.Center;
            dirToMouse.Normalize();
            _currentDirectionIndex = GetDirectionFromVector(dirToMouse);

            if (_currentDirectionIndex == 2) _flipEffect = SpriteEffects.FlipHorizontally;
            else _flipEffect = SpriteEffects.None;

            string animName = (attackNum == 1) ? "Attack1" : "Attack2";
            float frameSpeed = (attackNum == 1) ? 80f : 120f;
            float duration = 10 * frameSpeed;

            CurrentState = (attackNum == 1) ? PlayerState.Attack1 : PlayerState.Attack2;
            _stateTimer = duration;
            _comboBuffered = false;

            // Reset hit list so each swing can hit targets again
            _enemiesHitThisAttack.Clear();
        }

        // Per-frame attack update: perform hit checks and end attack when timer expires
        private void UpdateAttack(GameTime gameTime, List<Enemy> enemies, int attackNum)
        {
            float dt = (float)gameTime.ElapsedGameTime.TotalMilliseconds;
            _stateTimer -= dt;

            // Perform the hit detection each frame while in attack state
            if (attackNum == 1)
                PerformSwordHit(enemies, 1.0f, 1.0f);
            else
                PerformSwordHit(enemies, 2.0f, 1.5f);

            // End attack and set cooldown
            if (_stateTimer <= 0)
            {
                CurrentState = PlayerState.Idle;
                _cooldownTimer = GameConstants.SwordCooldown;
                _debugSwordBox = Rectangle.Empty;
            }
        }

        private Rectangle _debugSwordBox;

        // Sword hit detection: builds a chest-relative hitbox and checks enemy intersections
        private void PerformSwordHit(List<Enemy> enemies, float damageMult, float knockbackMult)
        {
            // Chest position used as sword origin (updates as player moves)
            Vector2 chestPosition = new Vector2(position.X, position.Y - 50);

            // Cardinal attack directions based on currentDirectionIndex
            Vector2 attackDir = Vector2.Zero;
            if (_currentDirectionIndex == 0) attackDir = new Vector2(0, 1);  // Down
            if (_currentDirectionIndex == 1) attackDir = new Vector2(0, -1); // Up
            if (_currentDirectionIndex == 2) attackDir = new Vector2(-1, 0); // Left
            if (_currentDirectionIndex == 3) attackDir = new Vector2(1, 0);  // Right

            // Build a square hitbox out in front of the chest
            float reach = 80f * knockbackMult;
            Vector2 hitCenter = chestPosition + (attackDir * reach);
            int boxSize = (int)(80 * knockbackMult);

            Rectangle swordHitbox = new Rectangle(
                (int)(hitCenter.X - boxSize / 2),
                (int)(hitCenter.Y - boxSize / 2),
                boxSize,
                boxSize
            );

            // Keep debug rectangle for drawing/inspection
            _debugSwordBox = swordHitbox;

            // Collision test per enemy; skip already-hit targets this swing
            foreach (var enemy in enemies.ToArray())
            {
                if (!enemy.IsAlive) continue;
                if (_enemiesHitThisAttack.Contains(enemy)) continue;

                Rectangle enemyRect = new Rectangle(
                    (int)enemy.Position.X - 30,
                    (int)enemy.Position.Y - 80,
                    60,
                    80
                );

                if (swordHitbox.Intersects(enemyRect))
                {
                    int finalDamage = (int)(GameConstants.SwordDamage * damageMult * DamageMultiplier);
                    CombatSystem.DealDamage(this, enemy, finalDamage);

                    Vector2 kb = enemy.Position - this.position;
                    if (kb != Vector2.Zero) kb.Normalize();
                    enemy.ApplyKnockback(kb * GameConstants.SwordKnockback * knockbackMult);

                    _enemiesHitThisAttack.Add(enemy);
                }
            }
        }

        // -----------------------
        // ICombatant methods
        // -----------------------

        public void TakeDamage(int amount, ICombatant attacker)
        {
            // Respect invincibility frames (dash)
            if (_isInvincible) return;
            if (!IsAlive) return;

            Health -= amount;

            if (Health <= 0)
            {
                Die();
            }
            else
            {
                CurrentState = PlayerState.Hurt;
                _stateTimer = 300f;
            }
        }

        // Not used; CombatSystem.DealDamage is called directly from attack code
        public void PerformAttack() { }

        // Choose animation key and flip sprite based on state and velocity
        private void UpdateAnimation(GameTime gameTime)
        {
            string animKey = "Idle";

            switch (CurrentState)
            {
                case PlayerState.Idle: animKey = "Idle"; break;
                case PlayerState.Run: animKey = "Run"; break;
                case PlayerState.Attack1: animKey = "Attack1"; break;
                case PlayerState.Attack2: animKey = "Attack2"; break;
                case PlayerState.Dash: animKey = "Dash"; break;
                case PlayerState.Hurt: animKey = "Hurt"; break;
                case PlayerState.Dead: animKey = "Death"; break;
            }

            // Only flip during non-attack movement states so attack facing stays locked to click direction.
            if (CurrentState == PlayerState.Run || CurrentState == PlayerState.Idle || CurrentState == PlayerState.Dash)
            {
                if (_velocity.X < -0.1f) _flipEffect = SpriteEffects.FlipHorizontally;
                else if (_velocity.X > 0.1f) _flipEffect = SpriteEffects.None;
            }

            _animManager.Play(animKey);
            _animManager.Update(gameTime);
        }

        // Enter death state; keep sprite visible so death animation plays
        public void Die()
        {
            CurrentState = PlayerState.Dead;
            CombatSystem.ClearTarget(this);
        }

        // -----------------------
        // DRAW
        // -----------------------
        public override void Draw(SpriteBatch spriteBatch)
        {
            // Visual offset corrects sprite drawing so feet align with logic position
            Vector2 visualOffset = new Vector2(0, 175);
            Vector2 drawPos = position + visualOffset;

            // Draw animation using AnimationManager
            _animManager.Draw(spriteBatch, drawPos, (float)Scale, _flipEffect, _currentDirectionIndex);

            // Debug drawing (commented out) shows hitboxes and logic dot; useful while tuning alignment.
            // Examples left in file for quick experiments.
        }
    }
}
using System;
using Microsoft.Xna.Framework;

namespace Pale_Roots_1
{
    // RotatingSprite: adds rotation helpers and obstacle-aware movement on top of Sprite.
    // - Used by Enemy, Sentry, Projectile and Ally to aim and move while respecting collisions.
    public class RotatingSprite : Sprite
    {
        // How quickly the sprite can turn toward a target (radians per update).
        public float rotationSpeed;

        public RotatingSprite(Game g, Microsoft.Xna.Framework.Graphics.Texture2D tx, Vector2 StartPosition, int NoOfFrames)
            : base(g, tx, StartPosition, NoOfFrames, 1)
        {
        }

        // Rotate smoothly to face another sprite instance (uses TurnToFace under the hood).
        public void follow(Sprite sp)
        {
            this.angleOfRotation = TurnToFace(position, sp.position, angleOfRotation, rotationSpeed);
        }

        // Compute a bounded rotation toward a point.
        // - Returns a new angle clamped by turnSpeed so rotation is smooth over multiple frames.
        protected static float TurnToFace(Vector2 position, Vector2 faceThis, float currentAngle, float turnSpeed)
        {
            float x = faceThis.X - position.X;
            float y = faceThis.Y - position.Y;
            float desiredAngle = (float)Math.Atan2(y, x);

            float difference = WrapAngle(desiredAngle - currentAngle);
            difference = MathHelper.Clamp(difference, -turnSpeed, turnSpeed);

            return WrapAngle(currentAngle + difference);
        }

        public override void Update(GameTime gametime)
        {
            base.Update(gametime);
        }

        public override void Draw(Microsoft.Xna.Framework.Graphics.SpriteBatch spriteBatch)
        {
            base.Draw(spriteBatch);
        }

        // Normalize an angle into [-PI, PI] so shortest rotation direction is used.
        private static float WrapAngle(float radians)
        {
            while (radians < -MathHelper.Pi)
            {
                radians += MathHelper.TwoPi;
            }
            while (radians > MathHelper.Pi)
            {
                radians -= MathHelper.TwoPi;
            }
            return radians;
        }

        // Move toward a target while checking collisions against obstacles.
        // - Movement resolves X and Y separately so the sprite can slide along obstacles.
        // - Updates angleOfRotation to face travel direction.
        public void MoveToward(Vector2 target, float speed, System.Collections.Generic.List<WorldObject> obstacles)
        {
            Vector2 direction = target - position;

            if (direction != Vector2.Zero)
            {
                direction.Normalize();
                Vector2 velocity = direction * speed;

                // Try X axis move; apply only if not colliding at the new X.
                Vector2 futurePosX = new Vector2(position.X + velocity.X, position.Y);
                if (!IsColliding(futurePosX, obstacles))
                {
                    position.X = futurePosX.X;
                }

                // Try Y axis move; apply only if not colliding at the new Y.
                Vector2 futurePosY = new Vector2(position.X, position.Y + velocity.Y);
                if (!IsColliding(futurePosY, obstacles))
                {
                    position.Y = futurePosY.Y;
                }

                // Face movement direction immediately.
                angleOfRotation = (float)Math.Atan2(direction.Y, direction.X);

                // Keep sprite inside map bounds (implemented on Sprite).
                ClampToMap();
            }
        }

        // Instantly set rotation to face a world point (no smoothing).
        public void SnapToFace(Vector2 target)
        {
            float x = target.X - position.X;
            float y = target.Y - position.Y;
            angleOfRotation = (float)Math.Atan2(y, x);
        }

        // Smooth follow wrapper that accepts a position rather than a Sprite.
        public void Follow(Vector2 targetPosition)
        {
            this.angleOfRotation = TurnToFace(position, targetPosition, angleOfRotation, rotationSpeed);
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;

namespace Pale_Roots_1
{
    // Base Sprite: minimal drawable game object with simple animation and basic collision helpers.
    // - Used by Player, Enemy, Ally, WorldObject, Projectile and other actors.
    // - Provides sprite sheet frame logic, a simple "feet" collision box helper and map clamping.
    public class Sprite
    {
        // Texture and rendering helpers
        protected Texture2D spriteImage;
        protected Game game;
        protected Vector2 origin;
        protected float angleOfRotation;
        protected int spriteDepth = 1;

        // Battle / gameplay bookkeeping (kept lightweight so CombatSystem can read/write)
        public int AttackerCount { get; set; } = 0;
        public Sprite CurrentCombatPartner;
        public Enemy.AISTATE CurrentAIState = Enemy.AISTATE.Charging;
        public bool Visible = true;
        public int Health { get; set; } = 10000;
        public float AttackCooldown = 0f;
        public float AttackSpeed = 1000f; // milliseconds per attack

        // World position and scale (position is treated as the logical center point)
        public Vector2 position;
        public double Scale { get; set; }

        // Animation / spritesheet fields
        protected int numberOfFrames = 0;
        protected int currentFrame = 0;
        protected int mililsecondsBetweenFrames = 100;
        protected float timer = 0f;
        public int spriteWidth = 0;
        public int spriteHeight = 0;
        public Rectangle sourceRectangle;

        // Optional source rect offset for spritesheets that pack many sprites
        protected int _sheetStartX = 0;
        protected int _sheetStartY = 0;

        // Convenience: center for systems that use a logical center point for targeting
        public Vector2 Center
        {
            get { return position; }
        }

        // Constructor sets texture, frame count, scale and origin based on the supplied sheet.
        public Sprite(Game g, Texture2D texture, Vector2 userPosition, int framecount, double scale)
        {
            this.game = g;
            this.spriteImage = texture;
            this.position = userPosition;
            this.numberOfFrames = framecount;
            this.Scale = scale;
            this.spriteHeight = spriteImage.Height;
            this.spriteWidth = spriteImage.Width / framecount;
            this.origin = new Vector2(spriteWidth / 2f, spriteHeight / 2f);
            this.sourceRectangle = new Rectangle(0, 0, spriteWidth, spriteHeight);
        }

        // Virtual placeholder; some subclasses (RotatingSprite) use a follow implementation.
        public virtual void follow(Sprite target) { }

        // Advance animation frames and update the source rectangle to the current frame.
        public virtual void Update(GameTime gametime)
        {
            timer += (float)gametime.ElapsedGameTime.TotalMilliseconds;
            if (timer > mililsecondsBetweenFrames)
            {
                currentFrame++;
                if (currentFrame >= numberOfFrames) currentFrame = 0;
                timer = 0f;
            }

            int frameOffsetX = currentFrame * spriteWidth;
            sourceRectangle = new Rectangle(_sheetStartX + frameOffsetX, _sheetStartY, spriteWidth, spriteHeight);
        }

        // Set a different source rectangle on the sheet (useful for Helper / WorldObject).
        public void SetSpriteSheetLocation(Rectangle source)
        {
            _sheetStartX = source.X;
            _sheetStartY = source.Y;

            this.spriteWidth = source.Width;
            this.spriteHeight = source.Height;
            this.sourceRectangle = source;

            this.origin = new Vector2(spriteWidth / 2f, spriteHeight / 2f);
        }

        // Keep the logical center point inside the map bounds (uses GameConstants.DefaultMapSize).
        // Call this after movement to avoid showing outside the world.
        protected void ClampToMap()
        {
            float mapW = GameConstants.DefaultMapSize.X;
            float mapH = GameConstants.DefaultMapSize.Y;

            float halfWidth = (spriteWidth * (float)Scale) / 2f;
            float halfHeight = (spriteHeight * (float)Scale) / 2f;

            if (position.X < halfWidth) position.X = halfWidth;
            if (position.X > mapW - halfWidth) position.X = mapW - halfWidth;

            if (position.Y < halfHeight) position.Y = halfHeight;
            if (position.Y > mapH - halfHeight) position.Y = mapH - halfHeight;
        }

        // Simple collision check used by movement helpers:
        // - Builds a small "feet" rectangle from newPos and checks against solid WorldObjects' CollisionBox.
        // - Returns true when a collision would occur (caller should avoid moving there).
        protected bool IsColliding(Vector2 newPos, List<WorldObject> objects)
        {
            if (objects == null) return false;

            // Feet box is a small rectangle near the bottom-center of the sprite.
            float scale = (float)Scale;
            int w = (int)(spriteWidth * scale * 0.4f); // 40% of sprite width
            int h = (int)(spriteHeight * scale * 0.2f); // 20% of sprite height

            int x = (int)(newPos.X - (w / 2));
            int y = (int)(newPos.Y + (spriteHeight * scale / 2) - h);

            Rectangle futureFeetBox = new Rectangle(x, y, w, h);

            foreach (var obj in objects)
            {
                if (obj.IsSolid && futureFeetBox.Intersects(obj.CollisionBox))
                {
                    return true;
                }
            }

            return false;
        }

        // Draw the sprite at `position` using the current sourceRectangle and origin.
        public virtual void Draw(SpriteBatch spriteBatch)
        {
            if (Visible)
            {
                spriteBatch.Draw(spriteImage, position, sourceRectangle,
                    Color.White, angleOfRotation, origin,
                    (float)Scale, SpriteEffects.None, spriteDepth);
            }
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Pale_Roots_1
{
    // Tile: simple data holder representing one map tile.
    // - `tileRef` links to a TileRef which stores sheet coordinates and the original tilemap value.
    // - LevelManager constructs Tile instances when loading a map and uses X/Y and TileWidth/TileHeight
    //   to place/render tiles or to build collision/logic structures.
    // - `Passable` is a quick flag used by pathing / collision checks to decide if actors can walk through.
    public class Tile
    {
        // Reference to sheet position and map value (see TileRef definition).
        public TileRef tileRef { get; set; }

        // Pixel size of this tile (usually equals GameConstants.TileSize but stored per-tile for flexibility).
        int _tileWidth;
        int _tileHeight;

        // Optional identifier for the tile (useful for lookups, editor IDs or serialization).
        int _id;
        public int Id
        {
            get { return _id; }
            set { _id = value; }
        }

        // Human-friendly name for debug / editor tooling.
        string _tileName;
        public string TileName
        {
            get { return _tileName; }
            set { _tileName = value; }
        }

        // Whether actors can pass through this tile (true = walkable).
        bool _passable;
        public bool Passable
        {
            get { return _passable; }
            set { _passable = value; }
        }

        // Tile grid coordinates (column,row). LevelManager typically sets these when parsing the tilemap.
        int _x;
        public int X
        {
            get { return _x; }
            set { _x = value; }
        }

        int _y;
        public int Y
        {
            get { return _y; }
            set { _y = value; }
        }

        // Width/Height in pixels for the tile; used when converting grid coords to world positions.
        public int TileWidth
        {
            get
            {
                return _tileWidth;
            }

            set
            {
                _tileWidth = value;
            }
        }
        public int TileHeight
        {
            get
            {
                return _tileHeight;
            }

            set
            {
                _tileHeight = value;
            }
        }
    }
}
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Pale_Roots_1
{
    // TileLayer: holds a 2D grid of Tile objects and draws them from a shared spritesheet.
    // - Constructed from a numeric LayerMap (int[,]) and a list of TileRef entries that map tilesheet cells -> world tiles.
    // - LevelManager creates TileLayer instances when loading tilemap data and then calls Draw each frame.
    public class TileLayer
    {
        // Size (pixels) of a single tile in the source spritesheet and the destination (world) tile size.
        int SourceTileSize = 16;
        int DestTileSize = 64;

        // Palette of tile references (sheet X/Y + map value). If empty, LayerMap values are used directly.
        List<TileRef> tileRefs = new List<TileRef>();

        // Dimensions and storage for tile grid
        int tileMapHeight;  // rows (LayerMap.GetLength(0))
        int tileMapWidth;   // columns (LayerMap.GetLength(1))
        Tile[,] _tiles;
        public Tile[,] Tiles
        {
            get { return _tiles; }
            set { _tiles = value; }
        }

        // Constructor:
        // - LayerMap: int[row, col] that describes which tile value belongs at each cell.
        // - MapSheetReferences: list of TileRef entries mapping indices -> sheet positions.
        // - destSize/sourceSize: destination (world) tile size and source spritesheet tile size in pixels.
        public TileLayer(int[,] LayerMap,List<TileRef> MapSheetReferences, int destSize, int sourceSize)
        {
            DestTileSize = destSize;
            SourceTileSize = sourceSize;

            tileRefs = MapSheetReferences;
            tileMapHeight = LayerMap.GetLength(0); // rows
            tileMapWidth = LayerMap.GetLength(1);  // cols
            Tiles = new Tile[tileMapHeight, tileMapWidth];

            // Note: Tiles[y, x] uses [row, col] indexing (y = row, x = col).
            for (int x = 0; x < tileMapWidth; x++)      // columns
                for (int y = 0; y < tileMapHeight; y++) // rows
                {
                    // If we have a palette (tileRefs), choose a random entry from it for visual variety.
                    // Otherwise fall back to the numeric value in LayerMap.
                    int chosenIndex = 0;
                    if (tileRefs != null && tileRefs.Count > 0)
                    {
                        chosenIndex = CombatSystem.RandomInt(0, tileRefs.Count);
                    }
                    else
                    {
                        chosenIndex = LayerMap[y, x];
                    }

                    // Create the Tile data object the rest of the engine will query.
                    // - X/Y are grid coordinates used when computing world positions.
                    // - Id stores the index used to pick a TileRef.
                    // - Passable defaults to true here (LevelManager can override later).
                    // - tileRef points at the sheet coordinates; when tileRefs is empty this may attempt to index by LayerMap value.
                    Tiles[y, x] =
                        new Tile
                        {
                            X = x,
                            Y = y,
                            Id = chosenIndex,
                            Passable = true,
                            tileRef = (tileRefs != null && tileRefs.Count > 0) ? tileRefs[chosenIndex] : tileRefs[LayerMap[y, x]]
                        };
                }
        }

        // Draw the entire layer:
        // - Uses Helper.SpriteSheet (shared Texture2D) as the source atlas.
        // - For each Tile we compute destination rect in world space and source rect inside the atlas.
        // - Dest uses grid coords * DestTileSize; source uses TileRef._sheetPosX/_sheetPosY * SourceTileSize.
        // - LevelManager / Game.Draw should ensure SpriteBatch.Begin was called with the camera matrix first.
        public void Draw(SpriteBatch spriteBatch)
        {
            foreach (var Tile in Tiles)
            {
                Rectangle destRect = new Rectangle(
                    Tile.X * DestTileSize,
                    Tile.Y * DestTileSize,
                    DestTileSize,
                    DestTileSize);

                Rectangle sourceRect = new Rectangle(
                    Tile.tileRef._sheetPosX * SourceTileSize,
                    Tile.tileRef._sheetPosY * SourceTileSize,
                    SourceTileSize,
                    SourceTileSize);

                spriteBatch.Draw(Helper.SpriteSheet, destRect, sourceRect, Color.White);
            }
        }
    }
}
namespace Pale_Roots_1
{
    // TileRef: small data holder that maps a tilemap value to a source cell on the tilesheet.
    // Used by TileLayer and Tile to compute the source rectangle when drawing tiles.
    public class TileRef
    {
        // Column index on the tilesheet (in tiles, not pixels).
        public int _sheetPosX;

        // Row index on the tilesheet (in tiles, not pixels).
        public int _sheetPosY;

        // The integer value stored in the map that this TileRef represents.
        // Level parsing code and editors use this to match tiles -> TileRef entries.
        public int _tileMapValue;

        // Simple constructor: supply sheet X/Y (tile coords) and the original map value.
        public TileRef(int x, int y, int val)
        {
            _sheetPosX = x;
            _sheetPosY = y;
            _tileMapValue = val;
        }
    }
}
